<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pynever.strategies.abstraction API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pynever.strategies.abstraction</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import abc

from numpy import ndarray

import pynever.nodes as nodes
import uuid
import numpy as np
import multiprocessing
import itertools
from typing import Set, List, Union, Tuple
import math
import scipy.spatial.distance as dist
import time
import logging

from pynever.tensor import Tensor
from ortools.linear_solver import pywraplp


logger_empty = logging.getLogger(&#34;pynever.strategies.abstraction.empty_times&#34;)
logger_lp = logging.getLogger(&#34;pynever.strategies.abstraction.lp_times&#34;)
logger_lb = logging.getLogger(&#34;pynever.strategies.abstraction.lb_times&#34;)
logger_ub = logging.getLogger(&#34;pynever.strategies.abstraction.ub_times&#34;)

# save_times = False
propagate_bounds = False
parallel = True


class AbsElement(abc.ABC):
    &#34;&#34;&#34;
    An abstract class used for our internal representation of a generic Abstract Element (e.g., interval, zonotope,
    polyhedra etc.)

    Attributes
    ----------
    identifier : str
        Identifier of the AbsElement.
    &#34;&#34;&#34;

    def __init__(self, identifier: str = None):
        if identifier is None:
            self.identifier = uuid.uuid4()
        else:
            self.identifier = identifier


class Star:
    &#34;&#34;&#34;
    A concrete class used for our internal representation of a Star.
    The Star is defined as {x | x = c + Va such that Ca &lt;= d}
    where c is a n-dimensional vector corresponding to the center of the Star.
    V is the n-by-m matrix composed by the basis vectors.
    a is the vector of m variables, C (p-by-m) and d (p-dim) are the matrix and the biases
    defining a set of constraints.

    We refer to &lt;Star-Based Reachability Analysis of Deep Neural Networks&gt;
    (https://link.springer.com/chapter/10.1007/978-3-030-30942-8_39) for details.

    Attributes
    ----------
    center : Tensor
        Center of the Star.
    basis_matrix : Tensor
        Matrix composed by the basis vectors of the Star
    predicate_matrix : Tensor
        Matrix of the Predicate.
    predicate_bias : Tensor
        Bias of the Predicate.
    ubs : list
        Upper bounds of the points defined by the Star.
    lbs : list
        Lower bounds of the points defined by the Star.
    is_empty : bool
        Boolean flag: True if the Star defines an empty set of points, False otherwise

    Methods
    ----------
    get_bounds()
        Function used to get the upper and lower bounds of the n variables of the star.
    check_if_empty()
        Function used to check if the star corresponds to an empty set.


    &#34;&#34;&#34;

    def __init__(self, predicate_matrix: Tensor, predicate_bias: Tensor, center: Tensor = None,
                 basis_matrix: Tensor = None, lbs: list = None, ubs: list = None, is_empty: bool = None):

        predicate_dim_message = f&#34;Error: the first dimension of the predicate_matrix ({predicate_matrix.shape[0]}) &#34; \
                                f&#34;must be equal to the dimension of the predicate_bias ({predicate_bias.shape[0]}).&#34;
        assert predicate_matrix.shape[0] == predicate_bias.shape[0], predicate_dim_message

        self.predicate_matrix = predicate_matrix
        self.predicate_bias = predicate_bias

        if center is None and basis_matrix is None:
            self.center = np.zeros((predicate_matrix.shape[1], 1))
            self.basis_matrix = np.identity(predicate_matrix.shape[1])

        else:
            center_dim_message = f&#34;Error: the first dimension of the basis_matrix ({basis_matrix.shape[0]}) &#34; \
                                 f&#34;must be equal to the dimension of the center ({center.shape[0]}).&#34;
            assert center.shape[0] == basis_matrix.shape[0], center_dim_message

            basis_dim_message = f&#34;Error: the second dimension of the basis_matrix ({basis_matrix.shape[1]}) &#34; \
                                f&#34;must be equal to the second dimension of the predicate_matrix &#34; \
                                f&#34;({predicate_matrix.shape[1]}).&#34;
            assert basis_matrix.shape[1] == predicate_matrix.shape[1], basis_dim_message

            self.center = center
            self.basis_matrix = basis_matrix

        if lbs is None:
            lbs = [None for i in range(self.center.shape[0])]

        if ubs is None:
            ubs = [None for i in range(self.center.shape[0])]

        self.lbs = lbs
        self.ubs = ubs
        self.is_empty = is_empty

        # Private Attributes used for the sampling of the star.
        self.__auxiliary_points = None
        self.__current_point = None

    def check_if_empty(self) -&gt; bool:
        &#34;&#34;&#34;
        Function used to check if the set of points defined by the star is empty.

        Return
        ---------
        bool
            True if the star defines an empty set of points, False otherwise.
        &#34;&#34;&#34;

        start_time = time.perf_counter()
        if self.is_empty is None:

            solver, alphas, constraints = self.__get_predicate_lp_solver()
            objective = solver.Objective()
            for j in range(self.predicate_matrix.shape[1]):
                objective.SetCoefficient(alphas[j], 0)
            objective.SetOffset(0)

            objective.SetMinimization()
            status = solver.Solve()
            if status == pywraplp.Solver.INFEASIBLE or status == pywraplp.Solver.ABNORMAL:
                self.is_empty = True
            else:
                self.is_empty = False

        end_time = time.perf_counter()
        logger_empty.debug(f&#34;{end_time - start_time},&#34;)

        return self.is_empty

    def get_bounds(self, i) -&gt; (float, float):
        &#34;&#34;&#34;
        Function used to get the upper and lower bounds of the n variables of the star.

        Return
        ---------
        (float, float)
            Tuple containing the lower and upper bounds of the variable i of the star
        &#34;&#34;&#34;

        if self.lbs[i] is None or self.ubs[i] is None or self.is_empty is None:

            # print(&#34;Computing bounds&#34;)
            start_time = time.perf_counter()

            solver, alphas, constraints = self.__get_predicate_lp_solver()
            objective = solver.Objective()
            for j in range(self.basis_matrix.shape[1]):
                objective.SetCoefficient(alphas[j], self.basis_matrix[i, j])
            objective.SetOffset(self.center[i, 0])

            objective.SetMinimization()

            lb_start = time.perf_counter()
            status = solver.Solve()
            lb_end = time.perf_counter()

            assert status == pywraplp.Solver.OPTIMAL, &#34;The LP problem was not Optimal&#34;

            if status == pywraplp.Solver.INFEASIBLE or status == pywraplp.Solver.ABNORMAL:
                self.is_empty = True
                self.lbs[i] = None
                self.ubs[i] = None
                ub_end = 0
                ub_start = 0
            else:
                self.is_empty = False

                lb = solver.Objective().Value()
                objective.SetMaximization()
                ub_start = time.perf_counter()
                status = solver.Solve()
                ub_end = time.perf_counter()
                ub = solver.Objective().Value()

                self.lbs[i] = lb
                self.ubs[i] = ub

            end_time = time.perf_counter()

            logger_lp.debug(f&#34;{end_time - start_time},&#34;)
            logger_lb.debug(f&#34;{ub_end - ub_start},&#34;)
            logger_ub.debug(f&#34;{lb_end - lb_start},&#34;)

        return self.lbs[i], self.ubs[i]

    def check_alpha_inside(self, alpha_point: Tensor) -&gt; bool:
        &#34;&#34;&#34;
        Function which checks if the alpha point passed as input is valid with respect to the constraints defined by the
        predicate matrix and bias of the star.

        Parameters
        ----------
        alpha_point : Tensor
            Point (with respect ot the predicate variables) whose validity is to test.

        Returns
        -------
        bool
            The result of the check as a boolean (True if the point is valid, False otherwise)
        &#34;&#34;&#34;

        dim_error_msg = f&#34;Wrong dimensionality for alpha_point: it should be {self.predicate_matrix.shape[1]} by one.&#34;
        assert alpha_point.shape[0] == self.predicate_matrix.shape[1], dim_error_msg
        tests = np.matmul(self.predicate_matrix, alpha_point) &lt;= self.predicate_bias
        test = np.all(tests)
        return test

    def check_point_inside(self, point: Tensor, epsilon: float) -&gt; bool:
        &#34;&#34;&#34;
        Function which checks if the point passed as input is valid with respect to the constraints defined by the
        predicate matrix and bias of the star.

        Parameters
        ----------
        point : Tensor
            Point whose validity is to test.
        epsilon : float
            Acceptable deviation from real point.

        Returns
        -------
        bool
            The result of the check as a boolean (True if the point is valid, False otherwise)

        &#34;&#34;&#34;

        solver = pywraplp.Solver.CreateSolver(&#39;GLOP&#39;)
        alphas = []
        for j in range(self.basis_matrix.shape[1]):
            new_alpha = solver.NumVar(-solver.infinity(), solver.infinity(), f&#39;alpha_{j}&#39;)
            alphas.append(new_alpha)

        constraints = []
        for k in range(self.predicate_matrix.shape[0]):
            new_constraint = solver.Constraint(-solver.infinity(), self.predicate_bias[k, 0])
            for j in range(self.predicate_matrix.shape[1]):
                new_constraint.SetCoefficient(alphas[j], self.predicate_matrix[k, j])
            constraints.append(new_constraint)

        for i in range(self.basis_matrix.shape[0]):
            lb = point[i][0] - self.center[i][0] - epsilon
            ub = point[i][0] - self.center[i][0] + epsilon
            new_constraint = solver.Constraint(lb, ub)
            for j in range(self.basis_matrix.shape[1]):
                new_constraint.SetCoefficient(alphas[j], self.basis_matrix[i, j])
            constraints.append(new_constraint)

        objective = solver.Objective()
        for j in range(self.predicate_matrix.shape[1]):
            objective.SetCoefficient(alphas[j], 0)
        objective.SetOffset(0)

        objective.SetMinimization()
        status = solver.Solve()

        return status == pywraplp.Solver.FEASIBLE or status == pywraplp.Solver.OPTIMAL

    def get_samples(self, num_samples: int, reset_auxiliary: bool = False, new_start: bool = False) -&gt; List[Tensor]:

        # As first thing we need to get a valid starting point:
        # assert not self.check_if_empty(), &#34;Empty Set: impossible to sample.&#34;
        if self.check_if_empty():
            return []

        if self.__auxiliary_points is None or reset_auxiliary:
            auxiliary_points = self.__get_auxiliary_points()
        else:
            auxiliary_points = self.__auxiliary_points

        if self.__current_point is None or new_start:
            starting_point = self.__get_starting_point()
            current_point = np.array(starting_point)
        else:
            current_point = self.__current_point

        # We begin the iterative process to generate the samples of interest.
        samples = []
        while len(samples) &lt; num_samples:

            direction = np.random.randn(self.predicate_matrix.shape[1], 1)
            direction = direction / dist.norm(direction)
            lambdas = []
            for i in range(self.predicate_matrix.shape[0]):
                if np.isclose(np.matmul(self.predicate_matrix[i, :], direction), 0):
                    lambdas.append(np.nan)
                else:
                    temp = auxiliary_points[i] - current_point
                    lam = np.matmul(self.predicate_matrix[i, :], temp) / (np.matmul(self.predicate_matrix[i, :],
                                                                                    direction))
                    lambdas.append(lam)
            lambdas = np.array(lambdas)

            try:
                lam_upper = np.min(lambdas[lambdas &gt;= 0])
                lam_lower = np.max(lambdas[lambdas &lt; 0])
            except Exception:
                raise RuntimeError(&#34;The current direction does not intersect&#34;
                                   &#34;any of the hyperplanes.&#34;)

            increment = np.random.uniform(low=lam_lower, high=lam_upper)
            next_point = current_point + increment * direction
            if self.check_alpha_inside(next_point):
                current_point = next_point
                star_point = self.center + np.matmul(self.basis_matrix, current_point)
                samples.append(star_point)
                self.__current_point = current_point

        return samples

    def __get_auxiliary_points(self) -&gt; List[Tensor]:
        &#34;&#34;&#34;
        Function which returns the auxiliary points for each plane of the predicate.

        Returns
        -------
        List[Tensor]
            List of the auxiliary points: one for each plane of the predicate.

        &#34;&#34;&#34;
        aux_points = []
        for i in range(self.predicate_matrix.shape[0]):
            p = np.zeros((self.predicate_matrix.shape[1], 1))
            plane = self.predicate_matrix[i, :]
            max_nonzero_index = np.argmax(np.where(plane != 0, plane, -np.inf))
            p[max_nonzero_index] = self.predicate_bias[i] / plane[max_nonzero_index]
            aux_points.append(p)

        return aux_points

    def __get_starting_point_by_bounds(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Function used to get the starting point for the hit and run algorithm.

        Return
        ---------
        (float, float)
            Tuple containing the lower and upper bounds of the variables of the predicate
        &#34;&#34;&#34;

        starting_point = []
        for i in range(self.predicate_matrix.shape[1]):

            solver, alphas, constraints = self.__get_predicate_lp_solver()
            objective = solver.Objective()
            for j in range(self.predicate_matrix.shape[1]):
                if j == i:
                    objective.SetCoefficient(alphas[j], 1)
                else:
                    objective.SetCoefficient(alphas[j], 0)

            objective.SetMinimization()
            status = solver.Solve()

            assert status == pywraplp.Solver.OPTIMAL, &#34;The LP problem was not Optimal&#34;

            lb = solver.Objective().Value()

            objective.SetMaximization()
            status = solver.Solve()

            assert status == pywraplp.Solver.OPTIMAL, &#34;The LP problem was not Optimal&#34;

            ub = solver.Objective().Value()

            starting_point.append([(lb + ub) / 2.0])

        starting_point = np.array(starting_point)
        return starting_point

    def __get_starting_point(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Function used to get the starting point for the hit and run algorithm.

        Return
        ---------
        (float, float)
            Tuple containing the lower and upper bounds of the variables of the predicate
        &#34;&#34;&#34;
        starting_point = []

        solver = pywraplp.Solver.CreateSolver(&#39;GLOP&#39;)
        alphas = []
        for j in range(self.basis_matrix.shape[1]):
            new_alpha = solver.NumVar(-solver.infinity(), solver.infinity(), f&#39;alpha_{j}&#39;)
            alphas.append(new_alpha)
        radius = solver.NumVar(0, solver.infinity(), &#39;radius&#39;)

        constraints = []
        for k in range(self.predicate_matrix.shape[0]):
            new_constraint = solver.Constraint(-solver.infinity(), self.predicate_bias[k, 0])
            for j in range(self.predicate_matrix.shape[1]):
                new_constraint.SetCoefficient(alphas[j], self.predicate_matrix[k, j])
            new_constraint.SetCoefficient(radius, np.linalg.norm(self.predicate_matrix[k, :], 2))
            constraints.append(new_constraint)

        objective = solver.Objective()
        for j in range(self.predicate_matrix.shape[1]):
            objective.SetCoefficient(alphas[j], 0)
        objective.SetCoefficient(radius, 1)

        objective.SetMaximization()
        status = solver.Solve()

        assert status == pywraplp.Solver.OPTIMAL, &#34;It was impossible to compute the Chebyshev center of the predicate.&#34;

        for alpha in alphas:
            #print(alpha.solution_value())
            starting_point.append([alpha.solution_value()])
        #print(radius.solution_value())

        starting_point = np.array(starting_point)

        return starting_point

    def __get_predicate_lp_solver(self) -&gt; (pywraplp.Solver, list, list):
        &#34;&#34;&#34;
        Creates an lp solver using pywraplp and adds the variables and constraints
        corresponding to the predicate of the star.

        Returns
        ---------
        (pywraplp.Solver, list, list)
            Respectively the lp solver, the variables and the constraints.
        &#34;&#34;&#34;

        solver = pywraplp.Solver.CreateSolver(&#39;GLOP&#39;)
        alphas = []
        for j in range(self.basis_matrix.shape[1]):
            new_alpha = solver.NumVar(-solver.infinity(), solver.infinity(), f&#39;alpha_{j}&#39;)
            alphas.append(new_alpha)

        constraints = []
        for k in range(self.predicate_matrix.shape[0]):
            new_constraint = solver.Constraint(-solver.infinity(), self.predicate_bias[k, 0])
            for j in range(self.predicate_matrix.shape[1]):
                new_constraint.SetCoefficient(alphas[j], self.predicate_matrix[k, j])
            constraints.append(new_constraint)

        return solver, alphas, constraints


class StarSet(AbsElement):
    &#34;&#34;&#34;
    Concrete class for our internal representation of a StarSet abstract element. A StarSet consist in a set
    of Star objects.

    Attributes
    ----------
    stars : Set[Star]
        Set of Star objects.
    &#34;&#34;&#34;

    def __init__(self, stars: Set[Star] = None, identifier: str = None):
        super().__init__(identifier)
        if stars is None:
            self.stars = set()
        else:
            self.stars = stars


def intersect_with_halfspace(star: Star, coef_mat: Tensor, bias_mat: Tensor) -&gt; Star:
    &#34;&#34;&#34;
    Function which takes as input a Star and a halfspace defined by its coefficient matrix and bias vector and returns
    the Star resulting from the intesection of the input Star with the halfspace.
    &#34;&#34;&#34;

    new_center = star.center
    new_basis_matrix = star.basis_matrix
    hs_pred_matrix = np.matmul(coef_mat, star.basis_matrix)
    hs_pred_bias = bias_mat - np.matmul(coef_mat, star.center)
    new_pred_matrix = np.vstack((star.predicate_matrix, hs_pred_matrix))
    new_pred_bias = np.vstack((star.predicate_bias, hs_pred_bias))

    new_star = Star(new_pred_matrix, new_pred_bias, new_center, new_basis_matrix)
    return new_star


def __mixed_step_relu(abs_input: Set[Star], var_index: int, refinement_flag: bool) -&gt; Set[Star]:

    abs_input = list(abs_input)
    abs_output = set()

    ref_flags = [refinement_flag for i in range(len(abs_input))]

    for i in range(len(abs_input)):

        star = abs_input[i]
        lb, ub = star.get_bounds(var_index)

        if not star.is_empty:

            mask = np.identity(star.center.shape[0])
            mask[var_index, var_index] = 0

            if lb &gt;= 0:
                abs_output = abs_output.union({star})

            elif ub &lt;= 0:
                new_center = np.matmul(mask, star.center)
                new_basis_mat = np.matmul(mask, star.basis_matrix)
                new_pred_mat = star.predicate_matrix
                new_pred_bias = star.predicate_bias
                if propagate_bounds:
                    lbs = []
                    lbs.extend(star.lbs)
                    ubs = []
                    ubs.extend(star.ubs)
                    lbs[var_index] = 0
                    ubs[var_index] = 0
                else:
                    lbs = None
                    ubs = None
                new_star = Star(new_pred_mat, new_pred_bias, new_center, new_basis_mat, lbs, ubs)
                abs_output = abs_output.union({new_star})

            else:

                if ref_flags[i]:

                    # Creating lower bound star.
                    lower_star_center = np.matmul(mask, star.center)
                    lower_star_basis_mat = np.matmul(mask, star.basis_matrix)
                    # Adding x &lt;= 0 constraints to the predicate.
                    lower_predicate_matrix = np.vstack((star.predicate_matrix, star.basis_matrix[var_index, :]))
                    # Possibile problema sulla dimensionalita&#39; di star.center[var_index]
                    lower_predicate_bias = np.vstack((star.predicate_bias, -star.center[var_index]))
                    if propagate_bounds:
                        lbs = []
                        lbs.extend(star.lbs)
                        ubs = []
                        ubs.extend(star.ubs)
                        lbs[var_index] = 0
                        ubs[var_index] = 0
                    else:
                        lbs = None
                        ubs = None
                    lower_star = Star(lower_predicate_matrix, lower_predicate_bias, lower_star_center,
                                      lower_star_basis_mat, lbs, ubs)

                    # Creating upper bound star.
                    upper_star_center = star.center
                    upper_star_basis_mat = star.basis_matrix
                    # Adding x &gt;= 0 constraints to the predicate.
                    upper_predicate_matrix = np.vstack((star.predicate_matrix, -star.basis_matrix[var_index, :]))
                    # Possibile problema sulla dimensionalita&#39; di star.center[var_index]
                    upper_predicate_bias = np.vstack((star.predicate_bias, star.center[var_index]))
                    if propagate_bounds:
                        lbs = []
                        lbs.extend(star.lbs)
                        ubs = []
                        ubs.extend(star.ubs)
                        lbs[var_index] = 0
                        ubs[var_index] = star.ubs[var_index]
                    else:
                        lbs = None
                        ubs = None
                    upper_star = Star(upper_predicate_matrix, upper_predicate_bias, upper_star_center,
                                      upper_star_basis_mat, lbs, ubs)

                    abs_output = abs_output.union({lower_star, upper_star})

                else:

                    col_c_mat = star.predicate_matrix.shape[1]
                    row_c_mat = star.predicate_matrix.shape[0]

                    c_mat_1 = np.zeros((1, col_c_mat + 1))
                    c_mat_1[0, col_c_mat] = -1
                    c_mat_2 = np.hstack((np.array([star.basis_matrix[var_index, :]]), -np.ones((1, 1))))
                    coef_3 = - ub / (ub - lb)
                    c_mat_3 = np.hstack((np.array([coef_3 * star.basis_matrix[var_index, :]]), np.ones((1, 1))))
                    c_mat_0 = np.hstack((star.predicate_matrix, np.zeros((row_c_mat, 1))))

                    d_0 = star.predicate_bias
                    d_1 = np.zeros((1, 1))
                    d_2 = -star.center[var_index] * np.ones((1, 1))
                    d_3 = np.array([(ub / (ub - lb)) * (star.center[var_index] - lb)])

                    new_pred_mat = np.vstack((c_mat_0, c_mat_1, c_mat_2, c_mat_3))
                    new_pred_bias = np.vstack((d_0, d_1, d_2, d_3))

                    new_center = np.matmul(mask, star.center)
                    temp_basis_mat = np.matmul(mask, star.basis_matrix)
                    temp_vec = np.zeros((star.basis_matrix.shape[0], 1))
                    temp_vec[var_index, 0] = 1
                    new_basis_mat = np.hstack((temp_basis_mat, temp_vec))
                    if propagate_bounds:
                        lbs = []
                        lbs.extend(star.lbs)
                        ubs = []
                        ubs.extend(star.ubs)
                        lbs[var_index] = 0
                        ubs[var_index] = star.ubs[var_index]
                    else:
                        lbs = None
                        ubs = None
                    new_star = Star(new_pred_mat, new_pred_bias, new_center, new_basis_mat, lbs, ubs)

                    abs_output = abs_output.union({new_star})

    return abs_output


def mixed_single_relu_forward(star: Star, heuristic: str, params: List) -&gt; Tuple[Set[Star], ndarray]:
    &#34;&#34;&#34;
    Utility function for the management of the forward for AbsReLUNode. It is outside
    the class scope since multiprocessing does not support parallelization with
    function internal to classes.
    &#34;&#34;&#34;

    assert heuristic == &#34;given_flags&#34; or heuristic == &#34;best_n_neurons&#34; or heuristic == &#34;best_n_neurons_rel&#34;,\
        &#34;Heuristic Selected is not valid&#34;

    temp_abs_input = {star}
    if star.check_if_empty():
        return set(), None
    else:

        n_areas = []
        for i in range(star.center.shape[0]):
            lb, ub = star.get_bounds(i)
            if lb &lt; 0 and ub &gt; 0:
                n_areas.append(-lb * ub / 2.0)
            else:
                n_areas.append(0)

        n_areas = np.array(n_areas)

        if heuristic == &#34;best_n_neurons&#34; or heuristic == &#34;best_n_neurons_rel&#34;:

            n_neurons = params[0]

            if n_neurons &gt; 0:

                # We compute the ordered indexes of the neurons with decreasing values of the areas.
                # Our idea is that a greater value for the area correspond to greater loss of precision if the
                # star is not refined for the corresponding neuron.
                if heuristic == &#34;best_n_neurons_rel&#34;:
                    relevances = params[1]
                    n_areas = n_areas * relevances

                sorted_indexes = np.flip(np.argsort(n_areas))
                index_to_refine = sorted_indexes[:n_neurons]
            else:
                index_to_refine = []

            refinement_flags = []
            for i in range(star.center.shape[0]):
                if i in index_to_refine:
                    refinement_flags.append(True)
                else:
                    refinement_flags.append(False)

        elif heuristic == &#34;given_flags&#34;:
            refinement_flags = params

        else:
            raise NotImplementedError

        for i in range(star.center.shape[0]):
            temp_abs_input = __mixed_step_relu(temp_abs_input, i, refinement_flags[i])

        return temp_abs_input, n_areas


def single_fc_forward(star: Star, weight: Tensor, bias: Tensor) -&gt; Set[Star]:
    &#34;&#34;&#34;
    Utility function for the management of the forward for AbsFullyConnectedNode. It is outside
    the class scope since multiprocessing does not support parallelization with
    function internal to classes.
    &#34;&#34;&#34;
    assert (weight.shape[1] == star.basis_matrix.shape[0])

    new_basis_matrix = np.matmul(weight, star.basis_matrix)
    new_center = np.matmul(weight, star.center) + bias
    new_predicate_matrix = star.predicate_matrix
    new_predicate_bias = star.predicate_bias

    if propagate_bounds:
        lbs = []
        ubs = []
        for i in range(new_center.shape[0]):

            w = weight[i, :]
            b = bias[i, 0]
            lb = b
            ub = b
            for j in range(len(w)):
                if star.lbs[j] is None or star.ubs[j] is None:
                    star.get_bounds(j)

                lb = lb + min(star.lbs[j] * w[j], star.ubs[j] * w[j])
                ub = ub + max(star.lbs[j] * w[j], star.ubs[j] * w[j])
            lbs.append(lb)
            ubs.append(ub)
    else:
        lbs = None
        ubs = None

    new_star = Star(new_predicate_matrix, new_predicate_bias, new_center, new_basis_matrix, lbs, ubs)

    return {new_star}


def sig(x: float) -&gt; float:
    &#34;&#34;&#34;
    Utility function computing the logistic function of the input.
    &#34;&#34;&#34;
    return 1.0 / (1.0 + math.exp(-x))


def sig_fod(x: float) -&gt; float:
    &#34;&#34;&#34;
    Utility function computing the first order derivative of the logistic function of the input.
    &#34;&#34;&#34;
    return math.exp(-x) / math.pow(1 + math.exp(-x), 2)


def area_sig_triangle(lb: float, ub: float) -&gt; float:
    &#34;&#34;&#34;
    Utility function computing the area of the triangle defined by an upper bound and a lower bound on the
    logistic function. In particular is the triangle composed by the two tangents and line passing by the two bounds.
    &#34;&#34;&#34;

    x_p = (ub * sig_fod(ub) - lb * sig_fod(lb)) / (sig_fod(ub) - sig_fod(lb)) - \
          (sig(ub) - sig(lb)) / (sig_fod(ub) - sig_fod(lb))

    y_p = sig_fod(ub) * (x_p - ub) + sig(ub)

    height = abs(y_p - (sig(ub) - sig(lb)) / (ub - lb) * x_p + sig(lb) - lb * (sig(ub) - sig(lb)) / (ub - lb)) / \
             math.sqrt(1 + math.pow((sig(ub) - sig(lb)) / (ub - lb), 2))

    base = math.sqrt(math.pow(ub - lb, 2) + math.pow(sig(ub) - sig(lb), 2))

    return base * height / 2.0


def __recursive_step_sigmoid(star: Star, var_index: int, approx_level: int, lb: float, ub: float, tolerance: float) -&gt; Set[Star]:

    assert approx_level &gt;= 0

    if abs(ub - lb) &lt; tolerance:

        if ub &lt;= 0:
            if ub + tolerance &gt; 0:
                ub = 0
            else:
                ub = ub + tolerance
            lb = lb - tolerance
        else:
            if lb - tolerance &lt; 0:
                lb = 0
            else:
                lb = lb - tolerance
            ub = ub + tolerance

    assert (lb &lt;= 0 and ub &lt;= 0) or (lb &gt;= 0 and ub &gt;= 0)

    mask = np.identity(star.center.shape[0])
    mask[var_index, var_index] = 0

    if approx_level == 0:

        if lb &lt; 0 and ub &lt;= 0:

            c_mat_1 = np.hstack((np.array([sig_fod(lb) * star.basis_matrix[var_index, :]]), -np.ones((1, 1))))
            c_mat_2 = np.hstack((np.array([sig_fod(ub) * star.basis_matrix[var_index, :]]), -np.ones((1, 1))))
            coef_3 = - (sig(ub) - sig(lb)) / (ub - lb)
            c_mat_3 = np.hstack((np.array([coef_3 * star.basis_matrix[var_index, :]]), np.ones((1, 1))))

            d_1 = np.array([-sig_fod(lb) * (star.center[var_index] - lb) - sig(lb)])
            d_2 = np.array([-sig_fod(ub) * (star.center[var_index] - ub) - sig(ub)])
            d_3 = np.array([-coef_3 * (star.center[var_index] - lb) + sig(lb)])

        else:

            c_mat_1 = np.hstack((np.array([-sig_fod(lb) * star.basis_matrix[var_index, :]]), np.ones((1, 1))))
            c_mat_2 = np.hstack((np.array([-sig_fod(ub) * star.basis_matrix[var_index, :]]), np.ones((1, 1))))
            coef_3 = (sig(ub) - sig(lb)) / (ub - lb)
            c_mat_3 = np.hstack((np.array([coef_3 * star.basis_matrix[var_index, :]]), -np.ones((1, 1))))

            d_1 = np.array([sig_fod(lb) * (star.center[var_index] - lb) + sig(lb)])
            d_2 = np.array([sig_fod(ub) * (star.center[var_index] - ub) + sig(ub)])
            d_3 = np.array([-coef_3 * (star.center[var_index] - lb) - sig(lb)])

        col_c_mat = star.predicate_matrix.shape[1]

        # Adding lb and ub bounds to enhance stability
        c_mat_lb = np.zeros((1, col_c_mat + 1))
        c_mat_lb[0, col_c_mat] = -1
        d_lb = -sig(lb) * np.ones((1, 1))

        c_mat_ub = np.zeros((1, col_c_mat + 1))
        c_mat_ub[0, col_c_mat] = 1
        d_ub = sig(ub) * np.ones((1, 1))

        row_c_mat = star.predicate_matrix.shape[0]
        c_mat_0 = np.hstack((star.predicate_matrix, np.zeros((row_c_mat, 1))))
        d_0 = star.predicate_bias

        new_pred_mat = np.vstack((c_mat_0, c_mat_1, c_mat_2, c_mat_3, c_mat_lb, c_mat_ub))
        new_pred_bias = np.vstack((d_0, d_1, d_2, d_3, d_lb, d_ub))

        new_center = np.matmul(mask, star.center)
        temp_basis_mat = np.matmul(mask, star.basis_matrix)
        temp_vec = np.zeros((star.basis_matrix.shape[0], 1))
        temp_vec[var_index, 0] = 1
        new_basis_mat = np.hstack((temp_basis_mat, temp_vec))

        new_star = Star(new_pred_mat, new_pred_bias, new_center, new_basis_mat)

        return {new_star}

    else:

        # We need to select the boundary between lb and ub. The optimal boundary is the one which minimizes the
        # area of the two resulting triangle. Since computing the optimal is too slow we do an approximate search
        # between lb and ub considering s search points.

        num_search_points = 10
        boundaries = np.linspace(lb, ub, num_search_points, endpoint=False)
        boundaries = boundaries[1:]

        best_boundary = None
        smallest_area = 99999999
        for boundary in boundaries:
            area_1 = area_sig_triangle(lb, boundary)
            area_2 = area_sig_triangle(boundary, ub)
            if area_1 + area_2 &lt; smallest_area:
                smallest_area = area_1 + area_2
                best_boundary = boundary

        star_set = set()
        star_set = star_set.union(__recursive_step_sigmoid(star, var_index, approx_level - 1, lb, best_boundary, tolerance))
        star_set = star_set.union(__recursive_step_sigmoid(star, var_index, approx_level - 1, best_boundary, ub, tolerance))

        return star_set


def __approx_step_sigmoid(abs_input: Set[Star], var_index: int, approx_level: int, tolerance: float) -&gt; Set[Star]:

    abs_output = set()
    for star in abs_input:

        if not star.check_if_empty():
            lb, ub = star.get_bounds(var_index)

            if (lb &lt; 0) and (ub &gt; 0):
                abs_output = abs_output.union(__recursive_step_sigmoid(star, var_index, approx_level, lb, 0,
                                                                       tolerance))
                abs_output = abs_output.union(__recursive_step_sigmoid(star, var_index, approx_level, 0, ub,
                                                                       tolerance))
            else:
                abs_output = abs_output.union(__recursive_step_sigmoid(star, var_index, approx_level, lb,
                                                                       ub, tolerance))

    return abs_output


def single_sigmoid_forward(star: Star, approx_levels: List[int]) -&gt; Set[Star]:
    &#34;&#34;&#34;
    Utility function for the management of the forward for AbsSigmoidNode. It is outside
    the class scope since multiprocessing does not support parallelization with
    function internal to classes.
    &#34;&#34;&#34;
    tolerance = 0.01
    temp_abs_input = {star}
    for i in range(star.center.shape[0]):
        temp_abs_input = __approx_step_sigmoid(temp_abs_input, i, approx_levels[i], tolerance)
        print(f&#34;Index {i}, NumStar: {len(temp_abs_input)}&#34;)
    return temp_abs_input


class RefinementState(abc.ABC):
    &#34;&#34;&#34;
    A class used for the internal control of the refinement strategies/heuristics applied in the abstraction refinement
    step. At present is not still used and it is just an abstract placeholder. It will be used in future
    implementations.
    &#34;&#34;&#34;
    pass


class AbsLayerNode(abc.ABC):
    &#34;&#34;&#34;
    An abstract class used for our internal representation of a generic Abstract Transformer Layer of an
    AbsNeural Network. Its concrete children correspond to real abstract interpretation network layers.

    Attributes
    ----------
    identifier : str
        Identifier of the AbsLayerNode.

    ref_node : LayerNode
        LayerNode di riferimento per l&#39;abstract transformer.

    Methods
    ----------
    forward(AbsElement)
        Function which takes an AbsElement and compute the corresponding output AbsElement based on the abstract
        transformer.

    backward(RefinementState)
        Function which takes a reference to the refinement state and update both it and the state of the abstract
        transformer to control the refinement component of the abstraction. At present the function is just a
        placeholder for future implementations.

    &#34;&#34;&#34;

    def __init__(self, identifier: str, ref_node: nodes.LayerNode):
        self.identifier = identifier
        self.ref_node = ref_node

    @abc.abstractmethod
    def forward(self, abs_input: AbsElement) -&gt; AbsElement:
        &#34;&#34;&#34;
        Compute the output AbsElement based on the input AbsElement and the characteristics of the
        concrete abstract transformer.

        Parameters
        ----------
        abs_input : AbsElement
            The input abstract element.

        Returns
        ----------
        AbsElement
            The AbsElement resulting from the computation corresponding to the abstract transformer.
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def backward(self, ref_state: RefinementState):
        &#34;&#34;&#34;
        Update the RefinementState. At present the function is just a placeholder for future implementations.

        Parameters
        ----------
        ref_state: RefinementState
            The RefinementState to update.
        &#34;&#34;&#34;
        pass


class AbsReLUNode(AbsLayerNode):
    &#34;&#34;&#34;
    A class used for our internal representation of a ReLU Abstract transformer.

    Attributes
    ----------
    identifier : str
        Identifier of the LayerNode.

    ref_node : ReLUNode
        Reference LayerNode for the abstract transformer.

    heuristic : str
        Heuristic used to decide the refinement level of the abstraction.
        At present can be only one of the following:
        - given_flags: the neuron to be refined are selected referring to the list given in params
        - best_n_neurons: for each star the n best neuron to refine are selected based on the loss of precision
          the abstraction would incur using the coarse over_approximation.
        - best_n_neurons_rel: for each star the n best neuron to refine are selected based on the loss of precision
          the abstraction would incur using the coarse over_approximation together with the neuron relevances values.

    params : List
        Parameters for the heuristic of interest.
        If the heuristic is given_flags then params is a List whose first element is the list of refinement flags.
        If the heuristic is best_n_neurons then params is a List whose first element is the number of neurons to refine.
        If the heuristic is best_n_neurons_rel then params is a List whose first element is a tuple containing
        the number of neurons to refine and a list containing the relevances of the neurons.

    Methods
    ----------
    forward(AbsElement)
        Function which takes an AbsElement and compute the corresponding output AbsElement based on the abstract
        transformer.

    backward(RefinementState)
        Function which takes a reference to the refinement state and update both it and the state of the abstract
        transformer to control the refinement component of the abstraction. At present the function is just a
        placeholder for future implementations.
    &#34;&#34;&#34;

    def __init__(self, identifier: str, ref_node: nodes.ReLUNode, heuristic: str, params: List):

        super().__init__(identifier, ref_node)

        self.heuristic = heuristic
        self.params = params
        self.n_areas = None

    def forward(self, abs_input: AbsElement) -&gt; AbsElement:
        &#34;&#34;&#34;
        Compute the output AbsElement based on the input AbsElement and the characteristics of the
        concrete abstract transformer.

        Parameters
        ----------
        abs_input : AbsElement
            The input abstract element.

        Returns
        ----------
        AbsElement
            The AbsElement resulting from the computation corresponding to the abstract transformer.
        &#34;&#34;&#34;

        if isinstance(abs_input, StarSet):
            if parallel:
                return self.__parallel_starset_forward(abs_input)
            else:
                return self.__starset_forward(abs_input)
        else:
            raise NotImplementedError

    def backward(self, ref_state: RefinementState):
        &#34;&#34;&#34;
        Update the RefinementState. At present the function is just a placeholder for future implementations.

        Parameters
        ----------
        ref_state: RefinementState
            The RefinementState to update.
        &#34;&#34;&#34;
        pass

    def __parallel_starset_forward(self, abs_input: StarSet) -&gt; StarSet:

        my_pool = multiprocessing.Pool(multiprocessing.cpu_count())
        parallel_results = my_pool.starmap(mixed_single_relu_forward, zip(abs_input.stars,
                                                                          itertools.repeat(self.heuristic),
                                                                          itertools.repeat(self.params)))
        my_pool.close()

        abs_output = StarSet()

        tot_areas = np.zeros(self.ref_node.in_dim)
        num_areas = 0
        for star_set, areas in parallel_results:
            if star_set != set():
                num_areas = num_areas + 1
                tot_areas = tot_areas + areas
            abs_output.stars = abs_output.stars.union(star_set)

        self.n_areas = tot_areas / num_areas

        return abs_output

    def __starset_forward(self, abs_input: StarSet) -&gt; StarSet:
        &#34;&#34;&#34;
        Forward function specialized for the concrete AbsElement StarSet.
        &#34;&#34;&#34;

        abs_output = StarSet()
        tot_areas = np.zeros(self.ref_node.in_dim)
        num_areas = 0
        for star in abs_input.stars:

            result, areas = mixed_single_relu_forward(star, self.heuristic, self.params)
            abs_output.stars = abs_output.stars.union(result)
            tot_areas = tot_areas + areas
            num_areas = num_areas + 1

        self.n_areas = tot_areas / num_areas

        return abs_output


class AbsFullyConnectedNode(AbsLayerNode):
    &#34;&#34;&#34;
    A class used for our internal representation of a Fully Connected Abstract transformer.

    Attributes
    ----------
    identifier : str
        Identifier of the LayerNode.

    ref_node : FullyConnectedNode
        LayerNode di riferimento per l&#39;abstract transformer.

    Methods
    ----------
    forward(AbsElement)
        Function which takes an AbsElement and compute the corresponding output AbsElement based on the abstract
        transformer.

    backward(RefinementState)
        Function which takes a reference to the refinement state and update both it and the state of the abstract
        transformer to control the refinement component of the abstraction. At present the function is just a
        placeholder for future implementations.
    &#34;&#34;&#34;

    def __init__(self, identifier: str, ref_node: nodes.FullyConnectedNode):
        super().__init__(identifier, ref_node)

    def forward(self, abs_input: AbsElement) -&gt; AbsElement:
        &#34;&#34;&#34;
        Compute the output AbsElement based on the input AbsElement and the characteristics of the
        concrete abstract transformer.

        Parameters
        ----------
        abs_input : AbsElement
            The input abstract element.

        Returns
        ----------
        AbsElement
            The AbsElement resulting from the computation corresponding to the abstract transformer.
        &#34;&#34;&#34;
        if isinstance(abs_input, StarSet):
            return self.__starset_forward(abs_input)
        else:
            raise NotImplementedError

    def __starset_forward(self, abs_input: StarSet) -&gt; StarSet:

        my_pool = multiprocessing.Pool(multiprocessing.cpu_count())
        # Need to expand bias since they are memorized like one-dimensional vector in fullyconnectednodes.
        if self.ref_node.bias.shape != (self.ref_node.weight.shape[0], 1):
            bias = np.expand_dims(self.ref_node.bias, 1)
        else:
            bias = self.ref_node.bias
        parallel_results = my_pool.starmap(single_fc_forward, zip(abs_input.stars,
                                                                  itertools.repeat(self.ref_node.weight),
                                                                  itertools.repeat(bias)))
        my_pool.close()
        abs_output = StarSet()
        for star_set in parallel_results:
            abs_output.stars = abs_output.stars.union(star_set)

        return abs_output

    def backward(self, ref_state: RefinementState):
        &#34;&#34;&#34;
        Update the RefinementState. At present the function is just a placeholder for future implementations.

        Parameters
        ----------
        ref_state: RefinementState
            The RefinementState to update.
        &#34;&#34;&#34;
        pass


class AbsSigmoidNode(AbsLayerNode):
    &#34;&#34;&#34;
    A class used for our internal representation of a Sigmoid transformer.

    Attributes
    ----------
    identifier : str
        Identifier of the LayerNode.

    ref_node : SigmoidNode
        LayerNode di riferimento per l&#39;abstract transformer.

    refinement_level : Union[int, List[int]]
        Refinement level for the sigmoid nodes: if it is a single int then that refinement level is applied to all
        the neurons of the layers, otherwise it is a list containing the refinement levels for each layers.

    Methods
    ----------
    forward(AbsElement)
        Function which takes an AbsElement and compute the corresponding output AbsElement based on the abstract
        transformer.

    backward(RefinementState)
        Function which takes a reference to the refinement state and update both it and the state of the abstract
        transformer to control the refinement component of the abstraction. At present the function is just a
        placeholder for future implementations.
    &#34;&#34;&#34;

    def __init__(self, identifier: str, ref_node: nodes.SigmoidNode, approx_levels: Union[int, List[int]] = None):
        super().__init__(identifier, ref_node)

        if approx_levels is None:
            approx_levels = [0 for i in range(ref_node.in_dim[-1])]
        elif isinstance(approx_levels, int):
            approx_levels = [approx_levels for i in range(ref_node.in_dim[-1])]

        self.approx_levels = approx_levels

    def forward(self, abs_input: AbsElement) -&gt; AbsElement:
        &#34;&#34;&#34;
        Compute the output AbsElement based on the input AbsElement and the characteristics of the
        concrete abstract transformer.

        Parameters
        ----------
        abs_input : AbsElement
            The input abstract element.

        Returns
        ----------
        AbsElement
            The AbsElement resulting from the computation corresponding to the abstract transformer.
        &#34;&#34;&#34;
        if isinstance(abs_input, StarSet):
            return self.__starset_forward(abs_input)
        else:
            raise NotImplementedError

    def __starset_forward(self, abs_input: StarSet) -&gt; StarSet:

        #parallel = True
        if parallel:
            abs_output = StarSet()
            my_pool = multiprocessing.Pool(1)
            parallel_results = my_pool.starmap(single_sigmoid_forward, zip(abs_input.stars,
                                                                           itertools.repeat(self.approx_levels)))
            my_pool.close()
            for star_set in parallel_results:
                abs_output.stars = abs_output.stars.union(star_set)
        else:
            abs_output = StarSet()
            for star in abs_input.stars:
                abs_output.stars = abs_output.stars.union(single_sigmoid_forward(star, self.approx_levels))

        return abs_output

    def backward(self, ref_state: RefinementState):
        &#34;&#34;&#34;
        Update the RefinementState. At present the function is just a placeholder for future implementations.

        Parameters
        ----------
        ref_state: RefinementState
            The RefinementState to update.
        &#34;&#34;&#34;
        pass


class AbsNeuralNetwork(abc.ABC):
    &#34;&#34;&#34;
    An abstract class used for our internal representation of a generic NeuralNetwork for Abstract Interpretation.
    It consists of a graph of AbsLayerNodes. The properties of the computational graph are specialized in the
    concrete classes. The method forward and backward calls the corresponding methods in the AbsLayerNodes following the
    correct order to compute the output AbsElement.

    Attributes
    ----------
    nodes : dict &lt;str, LayerNode&gt;
        Dictionary containing str keys and AbsLayerNodes values. It contains the nodes of the graph,
        the identifier of the node of interest is used as a key in the nodes dictionary.

    edges : dict &lt;str, list &lt;str&gt;&gt;
        Dictionary of identifiers of AbsLayerNodes, it contains for each nodes identified by the keys, the list of nodes
        connected to it.

    Methods
    ----------
    forward(AbsElement)
        Function which takes an AbsElement and compute the corresponding output AbsElement based on the AbsLayerNode
        of the network.

    backward(RefinementState)
        Function which takes a reference to the refinement state and update both it and the state of the AbsLayerNodes
        to control the refinement component of the abstraction. At present the function is just a placeholder
        for future implementations.

    &#34;&#34;&#34;

    def __init__(self):
        self.nodes = {}
        self.edges = {}

    def forward(self, abs_input: AbsElement) -&gt; AbsElement:
        &#34;&#34;&#34;
        Compute the output AbsElement based on the input AbsElement and the characteristics of the
        concrete abstract transformers.

        Parameters
        ----------
        abs_input : AbsElement
            The input abstract element.

        Returns
        ----------
        AbsElement
            The AbsElement resulting from the computation corresponding to the abstract transformer.
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def backward(self, ref_state: RefinementState):
        &#34;&#34;&#34;
        Update the RefinementState. At present the function is just a placeholder for future implementations.

        Parameters
        ----------
        ref_state: RefinementState
            The RefinementState to update.
        &#34;&#34;&#34;
        pass


class AbsSeqNetwork(AbsNeuralNetwork):
    &#34;&#34;&#34;
    Concrete children of AbsNeuralNetwork representing a sequential AbsNeuralNetwork.
    It consists of a graph of LayerNodes. The computational graph of a SequentialNetwork must
    correspond to a standard list. The method forward and backward calls the corresponding methods
    in the AbsLayerNodes following the correct order to compute the output AbsElement.

    Attributes
    ----------
    identifier : str
        Identifier of the Sequential AbsNeuralNetwork.

    Methods
    -------
    add_node(LayerNode)
        Procedure to add a new AbsLayerNode to the sequential AbsNeuralNetwork.

    get_first_node()
        Procedure to extract the first AbsLayerNode of the sequential AbsNeuralNetwork.

    get_next_node(LayerNode)
        Procedure to get the next AbsLayerNode of the AbsNeuralNetwork given an input AbsLayerNode

    get_last_node()
        Procedure to extract the last AbsLayerNode of the sequential AbsNeuralNetwork.

    forward(AbsElement)
        Function which takes an AbsElement and compute the corresponding output AbsElement based on the AbsLayerNode
        of the network.

    backward(RefinementState)
        Function which takes a reference to the refinement state and update both it and the state of the AbsLayerNodes
        to control the refinement component of the abstraction. At present the function is just a placeholder for
        future implementations.

    &#34;&#34;&#34;

    def __init__(self, identifier: str):

        super().__init__()
        self.identifier = identifier

    def add_node(self, node: AbsLayerNode):
        &#34;&#34;&#34;
        Procedure to add a new AbsLayerNode. In sequential network the new node must be connected directly to the
        previous node forming a list.

        Parameters
        ----------
        node : AbsLayerNode
            New node to add to the Sequential network.

        &#34;&#34;&#34;

        if len(self.nodes.keys()) == 0:
            self.nodes[node.identifier] = node
            self.edges[node.identifier] = []
        else:
            previous_node_key = self.get_last_node().identifier
            self.nodes[node.identifier] = node
            self.edges[previous_node_key].append(node.identifier)
            self.edges[node.identifier] = []

    def get_first_node(self) -&gt; AbsLayerNode:
        &#34;&#34;&#34;
        Procedure to get the first AbsLayerNode of the network.

        Return
        ---------
        AbsLayerNode
            The first node of the network.

        &#34;&#34;&#34;
        assert self.nodes

        keys = [key for key in self.nodes.keys()]
        for key in self.nodes.keys():
            for sub_key in self.nodes.keys():
                if sub_key in self.edges[key]:
                    keys.remove(sub_key)

        return self.nodes[keys[0]]

    def get_next_node(self, node: AbsLayerNode) -&gt; AbsLayerNode:
        &#34;&#34;&#34;
        Procedure to get the next AbsLayerNode of the network given an input AbsLayerNode.

        Return
        ---------
        LayerNode
            The next node of the network.

        &#34;&#34;&#34;

        assert self.nodes

        next_node = None
        if node is not None:
            current_key = node.identifier
            if len(self.edges[current_key]) != 0:
                next_key = self.edges[current_key][0]
                next_node = self.nodes[next_key]
        else:
            next_node = self.get_first_node()

        return next_node

    def get_last_node(self) -&gt; AbsLayerNode:
        &#34;&#34;&#34;
        Procedure to get the last AbsLayerNode of the network.

        Return
        ---------
        AbsLayerNode
            The last node of the network.

        &#34;&#34;&#34;

        assert self.nodes

        current_node = self.get_first_node()
        while self.get_next_node(current_node) is not None:
            current_node = self.get_next_node(current_node)

        return current_node

    def forward(self, abs_input: AbsElement) -&gt; AbsElement:
        &#34;&#34;&#34;
        Compute the output AbsElement based on the input AbsElement and the characteristics of the
        concrete abstract transformers.

        Parameters
        ----------
        abs_input : AbsElement
            The input abstract element.

        Returns
        ----------
        AbsElement
            The AbsElement resulting from the computation corresponding to the abstract transformer.
        &#34;&#34;&#34;

        current_node = self.get_first_node()
        while current_node is not None:
            abs_input = current_node.forward(abs_input)
            current_node = self.get_next_node(current_node)

        return abs_input

    def backward(self, ref_state: RefinementState):
        &#34;&#34;&#34;
        Update the RefinementState. At present the function is just a placeholder for future implementations.

        Parameters
        ----------
        ref_state: RefinementState
            The RefinementState to update.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pynever.strategies.abstraction.area_sig_triangle"><code class="name flex">
<span>def <span class="ident">area_sig_triangle</span></span>(<span>lb:float, ub:float) >float</span>
</code></dt>
<dd>
<div class="desc"><p>Utility function computing the area of the triangle defined by an upper bound and a lower bound on the
logistic function. In particular is the triangle composed by the two tangents and line passing by the two bounds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area_sig_triangle(lb: float, ub: float) -&gt; float:
    &#34;&#34;&#34;
    Utility function computing the area of the triangle defined by an upper bound and a lower bound on the
    logistic function. In particular is the triangle composed by the two tangents and line passing by the two bounds.
    &#34;&#34;&#34;

    x_p = (ub * sig_fod(ub) - lb * sig_fod(lb)) / (sig_fod(ub) - sig_fod(lb)) - \
          (sig(ub) - sig(lb)) / (sig_fod(ub) - sig_fod(lb))

    y_p = sig_fod(ub) * (x_p - ub) + sig(ub)

    height = abs(y_p - (sig(ub) - sig(lb)) / (ub - lb) * x_p + sig(lb) - lb * (sig(ub) - sig(lb)) / (ub - lb)) / \
             math.sqrt(1 + math.pow((sig(ub) - sig(lb)) / (ub - lb), 2))

    base = math.sqrt(math.pow(ub - lb, 2) + math.pow(sig(ub) - sig(lb), 2))

    return base * height / 2.0</code></pre>
</details>
</dd>
<dt id="pynever.strategies.abstraction.intersect_with_halfspace"><code class="name flex">
<span>def <span class="ident">intersect_with_halfspace</span></span>(<span>star:<a title="pynever.strategies.abstraction.Star" href="#pynever.strategies.abstraction.Star">Star</a>, coef_mat:<a title="pynever.tensor.Tensor" href="../tensor.html#pynever.tensor.Tensor">Tensor</a>, bias_mat:<a title="pynever.tensor.Tensor" href="../tensor.html#pynever.tensor.Tensor">Tensor</a>) ><a title="pynever.strategies.abstraction.Star" href="#pynever.strategies.abstraction.Star">Star</a></span>
</code></dt>
<dd>
<div class="desc"><p>Function which takes as input a Star and a halfspace defined by its coefficient matrix and bias vector and returns
the Star resulting from the intesection of the input Star with the halfspace.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersect_with_halfspace(star: Star, coef_mat: Tensor, bias_mat: Tensor) -&gt; Star:
    &#34;&#34;&#34;
    Function which takes as input a Star and a halfspace defined by its coefficient matrix and bias vector and returns
    the Star resulting from the intesection of the input Star with the halfspace.
    &#34;&#34;&#34;

    new_center = star.center
    new_basis_matrix = star.basis_matrix
    hs_pred_matrix = np.matmul(coef_mat, star.basis_matrix)
    hs_pred_bias = bias_mat - np.matmul(coef_mat, star.center)
    new_pred_matrix = np.vstack((star.predicate_matrix, hs_pred_matrix))
    new_pred_bias = np.vstack((star.predicate_bias, hs_pred_bias))

    new_star = Star(new_pred_matrix, new_pred_bias, new_center, new_basis_matrix)
    return new_star</code></pre>
</details>
</dd>
<dt id="pynever.strategies.abstraction.mixed_single_relu_forward"><code class="name flex">
<span>def <span class="ident">mixed_single_relu_forward</span></span>(<span>star:<a title="pynever.strategies.abstraction.Star" href="#pynever.strategies.abstraction.Star">Star</a>, heuristic:str, params:List) >Tuple[Set[<a title="pynever.strategies.abstraction.Star" href="#pynever.strategies.abstraction.Star">Star</a>],numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Utility function for the management of the forward for AbsReLUNode. It is outside
the class scope since multiprocessing does not support parallelization with
function internal to classes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mixed_single_relu_forward(star: Star, heuristic: str, params: List) -&gt; Tuple[Set[Star], ndarray]:
    &#34;&#34;&#34;
    Utility function for the management of the forward for AbsReLUNode. It is outside
    the class scope since multiprocessing does not support parallelization with
    function internal to classes.
    &#34;&#34;&#34;

    assert heuristic == &#34;given_flags&#34; or heuristic == &#34;best_n_neurons&#34; or heuristic == &#34;best_n_neurons_rel&#34;,\
        &#34;Heuristic Selected is not valid&#34;

    temp_abs_input = {star}
    if star.check_if_empty():
        return set(), None
    else:

        n_areas = []
        for i in range(star.center.shape[0]):
            lb, ub = star.get_bounds(i)
            if lb &lt; 0 and ub &gt; 0:
                n_areas.append(-lb * ub / 2.0)
            else:
                n_areas.append(0)

        n_areas = np.array(n_areas)

        if heuristic == &#34;best_n_neurons&#34; or heuristic == &#34;best_n_neurons_rel&#34;:

            n_neurons = params[0]

            if n_neurons &gt; 0:

                # We compute the ordered indexes of the neurons with decreasing values of the areas.
                # Our idea is that a greater value for the area correspond to greater loss of precision if the
                # star is not refined for the corresponding neuron.
                if heuristic == &#34;best_n_neurons_rel&#34;:
                    relevances = params[1]
                    n_areas = n_areas * relevances

                sorted_indexes = np.flip(np.argsort(n_areas))
                index_to_refine = sorted_indexes[:n_neurons]
            else:
                index_to_refine = []

            refinement_flags = []
            for i in range(star.center.shape[0]):
                if i in index_to_refine:
                    refinement_flags.append(True)
                else:
                    refinement_flags.append(False)

        elif heuristic == &#34;given_flags&#34;:
            refinement_flags = params

        else:
            raise NotImplementedError

        for i in range(star.center.shape[0]):
            temp_abs_input = __mixed_step_relu(temp_abs_input, i, refinement_flags[i])

        return temp_abs_input, n_areas</code></pre>
</details>
</dd>
<dt id="pynever.strategies.abstraction.sig"><code class="name flex">
<span>def <span class="ident">sig</span></span>(<span>x:float) >float</span>
</code></dt>
<dd>
<div class="desc"><p>Utility function computing the logistic function of the input.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sig(x: float) -&gt; float:
    &#34;&#34;&#34;
    Utility function computing the logistic function of the input.
    &#34;&#34;&#34;
    return 1.0 / (1.0 + math.exp(-x))</code></pre>
</details>
</dd>
<dt id="pynever.strategies.abstraction.sig_fod"><code class="name flex">
<span>def <span class="ident">sig_fod</span></span>(<span>x:float) >float</span>
</code></dt>
<dd>
<div class="desc"><p>Utility function computing the first order derivative of the logistic function of the input.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sig_fod(x: float) -&gt; float:
    &#34;&#34;&#34;
    Utility function computing the first order derivative of the logistic function of the input.
    &#34;&#34;&#34;
    return math.exp(-x) / math.pow(1 + math.exp(-x), 2)</code></pre>
</details>
</dd>
<dt id="pynever.strategies.abstraction.single_fc_forward"><code class="name flex">
<span>def <span class="ident">single_fc_forward</span></span>(<span>star:<a title="pynever.strategies.abstraction.Star" href="#pynever.strategies.abstraction.Star">Star</a>, weight:<a title="pynever.tensor.Tensor" href="../tensor.html#pynever.tensor.Tensor">Tensor</a>, bias:<a title="pynever.tensor.Tensor" href="../tensor.html#pynever.tensor.Tensor">Tensor</a>) >Set[<a title="pynever.strategies.abstraction.Star" href="#pynever.strategies.abstraction.Star">Star</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Utility function for the management of the forward for AbsFullyConnectedNode. It is outside
the class scope since multiprocessing does not support parallelization with
function internal to classes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def single_fc_forward(star: Star, weight: Tensor, bias: Tensor) -&gt; Set[Star]:
    &#34;&#34;&#34;
    Utility function for the management of the forward for AbsFullyConnectedNode. It is outside
    the class scope since multiprocessing does not support parallelization with
    function internal to classes.
    &#34;&#34;&#34;
    assert (weight.shape[1] == star.basis_matrix.shape[0])

    new_basis_matrix = np.matmul(weight, star.basis_matrix)
    new_center = np.matmul(weight, star.center) + bias
    new_predicate_matrix = star.predicate_matrix
    new_predicate_bias = star.predicate_bias

    if propagate_bounds:
        lbs = []
        ubs = []
        for i in range(new_center.shape[0]):

            w = weight[i, :]
            b = bias[i, 0]
            lb = b
            ub = b
            for j in range(len(w)):
                if star.lbs[j] is None or star.ubs[j] is None:
                    star.get_bounds(j)

                lb = lb + min(star.lbs[j] * w[j], star.ubs[j] * w[j])
                ub = ub + max(star.lbs[j] * w[j], star.ubs[j] * w[j])
            lbs.append(lb)
            ubs.append(ub)
    else:
        lbs = None
        ubs = None

    new_star = Star(new_predicate_matrix, new_predicate_bias, new_center, new_basis_matrix, lbs, ubs)

    return {new_star}</code></pre>
</details>
</dd>
<dt id="pynever.strategies.abstraction.single_sigmoid_forward"><code class="name flex">
<span>def <span class="ident">single_sigmoid_forward</span></span>(<span>star:<a title="pynever.strategies.abstraction.Star" href="#pynever.strategies.abstraction.Star">Star</a>, approx_levels:List[int]) >Set[<a title="pynever.strategies.abstraction.Star" href="#pynever.strategies.abstraction.Star">Star</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Utility function for the management of the forward for AbsSigmoidNode. It is outside
the class scope since multiprocessing does not support parallelization with
function internal to classes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def single_sigmoid_forward(star: Star, approx_levels: List[int]) -&gt; Set[Star]:
    &#34;&#34;&#34;
    Utility function for the management of the forward for AbsSigmoidNode. It is outside
    the class scope since multiprocessing does not support parallelization with
    function internal to classes.
    &#34;&#34;&#34;
    tolerance = 0.01
    temp_abs_input = {star}
    for i in range(star.center.shape[0]):
        temp_abs_input = __approx_step_sigmoid(temp_abs_input, i, approx_levels[i], tolerance)
        print(f&#34;Index {i}, NumStar: {len(temp_abs_input)}&#34;)
    return temp_abs_input</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pynever.strategies.abstraction.AbsElement"><code class="flex name class">
<span>class <span class="ident">AbsElement</span></span>
<span>(</span><span>identifier:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An abstract class used for our internal representation of a generic Abstract Element (e.g., interval, zonotope,
polyhedra etc.)</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>identifier</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier of the AbsElement.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsElement(abc.ABC):
    &#34;&#34;&#34;
    An abstract class used for our internal representation of a generic Abstract Element (e.g., interval, zonotope,
    polyhedra etc.)

    Attributes
    ----------
    identifier : str
        Identifier of the AbsElement.
    &#34;&#34;&#34;

    def __init__(self, identifier: str = None):
        if identifier is None:
            self.identifier = uuid.uuid4()
        else:
            self.identifier = identifier</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pynever.strategies.abstraction.StarSet" href="#pynever.strategies.abstraction.StarSet">StarSet</a></li>
</ul>
</dd>
<dt id="pynever.strategies.abstraction.AbsFullyConnectedNode"><code class="flex name class">
<span>class <span class="ident">AbsFullyConnectedNode</span></span>
<span>(</span><span>identifier:str, ref_node:<a title="pynever.nodes.FullyConnectedNode" href="../nodes.html#pynever.nodes.FullyConnectedNode">FullyConnectedNode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A class used for our internal representation of a Fully Connected Abstract transformer.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>identifier</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier of the LayerNode.</dd>
<dt><strong><code>ref_node</code></strong> :&ensp;<code>FullyConnectedNode</code></dt>
<dd>LayerNode di riferimento per l'abstract transformer.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>forward(AbsElement)
Function which takes an AbsElement and compute the corresponding output AbsElement based on the abstract
transformer.</p>
<p>backward(RefinementState)
Function which takes a reference to the refinement state and update both it and the state of the abstract
transformer to control the refinement component of the abstraction. At present the function is just a
placeholder for future implementations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsFullyConnectedNode(AbsLayerNode):
    &#34;&#34;&#34;
    A class used for our internal representation of a Fully Connected Abstract transformer.

    Attributes
    ----------
    identifier : str
        Identifier of the LayerNode.

    ref_node : FullyConnectedNode
        LayerNode di riferimento per l&#39;abstract transformer.

    Methods
    ----------
    forward(AbsElement)
        Function which takes an AbsElement and compute the corresponding output AbsElement based on the abstract
        transformer.

    backward(RefinementState)
        Function which takes a reference to the refinement state and update both it and the state of the abstract
        transformer to control the refinement component of the abstraction. At present the function is just a
        placeholder for future implementations.
    &#34;&#34;&#34;

    def __init__(self, identifier: str, ref_node: nodes.FullyConnectedNode):
        super().__init__(identifier, ref_node)

    def forward(self, abs_input: AbsElement) -&gt; AbsElement:
        &#34;&#34;&#34;
        Compute the output AbsElement based on the input AbsElement and the characteristics of the
        concrete abstract transformer.

        Parameters
        ----------
        abs_input : AbsElement
            The input abstract element.

        Returns
        ----------
        AbsElement
            The AbsElement resulting from the computation corresponding to the abstract transformer.
        &#34;&#34;&#34;
        if isinstance(abs_input, StarSet):
            return self.__starset_forward(abs_input)
        else:
            raise NotImplementedError

    def __starset_forward(self, abs_input: StarSet) -&gt; StarSet:

        my_pool = multiprocessing.Pool(multiprocessing.cpu_count())
        # Need to expand bias since they are memorized like one-dimensional vector in fullyconnectednodes.
        if self.ref_node.bias.shape != (self.ref_node.weight.shape[0], 1):
            bias = np.expand_dims(self.ref_node.bias, 1)
        else:
            bias = self.ref_node.bias
        parallel_results = my_pool.starmap(single_fc_forward, zip(abs_input.stars,
                                                                  itertools.repeat(self.ref_node.weight),
                                                                  itertools.repeat(bias)))
        my_pool.close()
        abs_output = StarSet()
        for star_set in parallel_results:
            abs_output.stars = abs_output.stars.union(star_set)

        return abs_output

    def backward(self, ref_state: RefinementState):
        &#34;&#34;&#34;
        Update the RefinementState. At present the function is just a placeholder for future implementations.

        Parameters
        ----------
        ref_state: RefinementState
            The RefinementState to update.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pynever.strategies.abstraction.AbsLayerNode" href="#pynever.strategies.abstraction.AbsLayerNode">AbsLayerNode</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pynever.strategies.abstraction.AbsLayerNode" href="#pynever.strategies.abstraction.AbsLayerNode">AbsLayerNode</a></b></code>:
<ul class="hlist">
<li><code><a title="pynever.strategies.abstraction.AbsLayerNode.backward" href="#pynever.strategies.abstraction.AbsLayerNode.backward">backward</a></code></li>
<li><code><a title="pynever.strategies.abstraction.AbsLayerNode.forward" href="#pynever.strategies.abstraction.AbsLayerNode.forward">forward</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pynever.strategies.abstraction.AbsLayerNode"><code class="flex name class">
<span>class <span class="ident">AbsLayerNode</span></span>
<span>(</span><span>identifier:str, ref_node:<a title="pynever.nodes.LayerNode" href="../nodes.html#pynever.nodes.LayerNode">LayerNode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>An abstract class used for our internal representation of a generic Abstract Transformer Layer of an
AbsNeural Network. Its concrete children correspond to real abstract interpretation network layers.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>identifier</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier of the AbsLayerNode.</dd>
<dt><strong><code>ref_node</code></strong> :&ensp;<code>LayerNode</code></dt>
<dd>LayerNode di riferimento per l'abstract transformer.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>forward(AbsElement)
Function which takes an AbsElement and compute the corresponding output AbsElement based on the abstract
transformer.</p>
<p>backward(RefinementState)
Function which takes a reference to the refinement state and update both it and the state of the abstract
transformer to control the refinement component of the abstraction. At present the function is just a
placeholder for future implementations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsLayerNode(abc.ABC):
    &#34;&#34;&#34;
    An abstract class used for our internal representation of a generic Abstract Transformer Layer of an
    AbsNeural Network. Its concrete children correspond to real abstract interpretation network layers.

    Attributes
    ----------
    identifier : str
        Identifier of the AbsLayerNode.

    ref_node : LayerNode
        LayerNode di riferimento per l&#39;abstract transformer.

    Methods
    ----------
    forward(AbsElement)
        Function which takes an AbsElement and compute the corresponding output AbsElement based on the abstract
        transformer.

    backward(RefinementState)
        Function which takes a reference to the refinement state and update both it and the state of the abstract
        transformer to control the refinement component of the abstraction. At present the function is just a
        placeholder for future implementations.

    &#34;&#34;&#34;

    def __init__(self, identifier: str, ref_node: nodes.LayerNode):
        self.identifier = identifier
        self.ref_node = ref_node

    @abc.abstractmethod
    def forward(self, abs_input: AbsElement) -&gt; AbsElement:
        &#34;&#34;&#34;
        Compute the output AbsElement based on the input AbsElement and the characteristics of the
        concrete abstract transformer.

        Parameters
        ----------
        abs_input : AbsElement
            The input abstract element.

        Returns
        ----------
        AbsElement
            The AbsElement resulting from the computation corresponding to the abstract transformer.
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def backward(self, ref_state: RefinementState):
        &#34;&#34;&#34;
        Update the RefinementState. At present the function is just a placeholder for future implementations.

        Parameters
        ----------
        ref_state: RefinementState
            The RefinementState to update.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pynever.strategies.abstraction.AbsFullyConnectedNode" href="#pynever.strategies.abstraction.AbsFullyConnectedNode">AbsFullyConnectedNode</a></li>
<li><a title="pynever.strategies.abstraction.AbsReLUNode" href="#pynever.strategies.abstraction.AbsReLUNode">AbsReLUNode</a></li>
<li><a title="pynever.strategies.abstraction.AbsSigmoidNode" href="#pynever.strategies.abstraction.AbsSigmoidNode">AbsSigmoidNode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pynever.strategies.abstraction.AbsLayerNode.backward"><code class="name flex">
<span>def <span class="ident">backward</span></span>(<span>self, ref_state:<a title="pynever.strategies.abstraction.RefinementState" href="#pynever.strategies.abstraction.RefinementState">RefinementState</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the RefinementState. At present the function is just a placeholder for future implementations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ref_state</code></strong> :&ensp;<code><a title="pynever.strategies.abstraction.RefinementState" href="#pynever.strategies.abstraction.RefinementState">RefinementState</a></code></dt>
<dd>The RefinementState to update.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def backward(self, ref_state: RefinementState):
    &#34;&#34;&#34;
    Update the RefinementState. At present the function is just a placeholder for future implementations.

    Parameters
    ----------
    ref_state: RefinementState
        The RefinementState to update.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="pynever.strategies.abstraction.AbsLayerNode.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, abs_input:<a title="pynever.strategies.abstraction.AbsElement" href="#pynever.strategies.abstraction.AbsElement">AbsElement</a>) ><a title="pynever.strategies.abstraction.AbsElement" href="#pynever.strategies.abstraction.AbsElement">AbsElement</a></span>
</code></dt>
<dd>
<div class="desc"><p>Compute the output AbsElement based on the input AbsElement and the characteristics of the
concrete abstract transformer.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>abs_input</code></strong> :&ensp;<code><a title="pynever.strategies.abstraction.AbsElement" href="#pynever.strategies.abstraction.AbsElement">AbsElement</a></code></dt>
<dd>The input abstract element.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pynever.strategies.abstraction.AbsElement" href="#pynever.strategies.abstraction.AbsElement">AbsElement</a></code></dt>
<dd>The AbsElement resulting from the computation corresponding to the abstract transformer.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def forward(self, abs_input: AbsElement) -&gt; AbsElement:
    &#34;&#34;&#34;
    Compute the output AbsElement based on the input AbsElement and the characteristics of the
    concrete abstract transformer.

    Parameters
    ----------
    abs_input : AbsElement
        The input abstract element.

    Returns
    ----------
    AbsElement
        The AbsElement resulting from the computation corresponding to the abstract transformer.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pynever.strategies.abstraction.AbsNeuralNetwork"><code class="flex name class">
<span>class <span class="ident">AbsNeuralNetwork</span></span>
</code></dt>
<dd>
<div class="desc"><p>An abstract class used for our internal representation of a generic NeuralNetwork for Abstract Interpretation.
It consists of a graph of AbsLayerNodes. The properties of the computational graph are specialized in the
concrete classes. The method forward and backward calls the corresponding methods in the AbsLayerNodes following the
correct order to compute the output AbsElement.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>nodes</code></strong> :&ensp;<code>dict &lt;str, LayerNode&gt;</code></dt>
<dd>Dictionary containing str keys and AbsLayerNodes values. It contains the nodes of the graph,
the identifier of the node of interest is used as a key in the nodes dictionary.</dd>
<dt><strong><code>edges</code></strong> :&ensp;<code>dict &lt;str, list &lt;str&gt;&gt;</code></dt>
<dd>Dictionary of identifiers of AbsLayerNodes, it contains for each nodes identified by the keys, the list of nodes
connected to it.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>forward(AbsElement)
Function which takes an AbsElement and compute the corresponding output AbsElement based on the AbsLayerNode
of the network.</p>
<p>backward(RefinementState)
Function which takes a reference to the refinement state and update both it and the state of the AbsLayerNodes
to control the refinement component of the abstraction. At present the function is just a placeholder
for future implementations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsNeuralNetwork(abc.ABC):
    &#34;&#34;&#34;
    An abstract class used for our internal representation of a generic NeuralNetwork for Abstract Interpretation.
    It consists of a graph of AbsLayerNodes. The properties of the computational graph are specialized in the
    concrete classes. The method forward and backward calls the corresponding methods in the AbsLayerNodes following the
    correct order to compute the output AbsElement.

    Attributes
    ----------
    nodes : dict &lt;str, LayerNode&gt;
        Dictionary containing str keys and AbsLayerNodes values. It contains the nodes of the graph,
        the identifier of the node of interest is used as a key in the nodes dictionary.

    edges : dict &lt;str, list &lt;str&gt;&gt;
        Dictionary of identifiers of AbsLayerNodes, it contains for each nodes identified by the keys, the list of nodes
        connected to it.

    Methods
    ----------
    forward(AbsElement)
        Function which takes an AbsElement and compute the corresponding output AbsElement based on the AbsLayerNode
        of the network.

    backward(RefinementState)
        Function which takes a reference to the refinement state and update both it and the state of the AbsLayerNodes
        to control the refinement component of the abstraction. At present the function is just a placeholder
        for future implementations.

    &#34;&#34;&#34;

    def __init__(self):
        self.nodes = {}
        self.edges = {}

    def forward(self, abs_input: AbsElement) -&gt; AbsElement:
        &#34;&#34;&#34;
        Compute the output AbsElement based on the input AbsElement and the characteristics of the
        concrete abstract transformers.

        Parameters
        ----------
        abs_input : AbsElement
            The input abstract element.

        Returns
        ----------
        AbsElement
            The AbsElement resulting from the computation corresponding to the abstract transformer.
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def backward(self, ref_state: RefinementState):
        &#34;&#34;&#34;
        Update the RefinementState. At present the function is just a placeholder for future implementations.

        Parameters
        ----------
        ref_state: RefinementState
            The RefinementState to update.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pynever.strategies.abstraction.AbsSeqNetwork" href="#pynever.strategies.abstraction.AbsSeqNetwork">AbsSeqNetwork</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pynever.strategies.abstraction.AbsNeuralNetwork.backward"><code class="name flex">
<span>def <span class="ident">backward</span></span>(<span>self, ref_state:<a title="pynever.strategies.abstraction.RefinementState" href="#pynever.strategies.abstraction.RefinementState">RefinementState</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the RefinementState. At present the function is just a placeholder for future implementations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ref_state</code></strong> :&ensp;<code><a title="pynever.strategies.abstraction.RefinementState" href="#pynever.strategies.abstraction.RefinementState">RefinementState</a></code></dt>
<dd>The RefinementState to update.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def backward(self, ref_state: RefinementState):
    &#34;&#34;&#34;
    Update the RefinementState. At present the function is just a placeholder for future implementations.

    Parameters
    ----------
    ref_state: RefinementState
        The RefinementState to update.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="pynever.strategies.abstraction.AbsNeuralNetwork.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, abs_input:<a title="pynever.strategies.abstraction.AbsElement" href="#pynever.strategies.abstraction.AbsElement">AbsElement</a>) ><a title="pynever.strategies.abstraction.AbsElement" href="#pynever.strategies.abstraction.AbsElement">AbsElement</a></span>
</code></dt>
<dd>
<div class="desc"><p>Compute the output AbsElement based on the input AbsElement and the characteristics of the
concrete abstract transformers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>abs_input</code></strong> :&ensp;<code><a title="pynever.strategies.abstraction.AbsElement" href="#pynever.strategies.abstraction.AbsElement">AbsElement</a></code></dt>
<dd>The input abstract element.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pynever.strategies.abstraction.AbsElement" href="#pynever.strategies.abstraction.AbsElement">AbsElement</a></code></dt>
<dd>The AbsElement resulting from the computation corresponding to the abstract transformer.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward(self, abs_input: AbsElement) -&gt; AbsElement:
    &#34;&#34;&#34;
    Compute the output AbsElement based on the input AbsElement and the characteristics of the
    concrete abstract transformers.

    Parameters
    ----------
    abs_input : AbsElement
        The input abstract element.

    Returns
    ----------
    AbsElement
        The AbsElement resulting from the computation corresponding to the abstract transformer.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pynever.strategies.abstraction.AbsReLUNode"><code class="flex name class">
<span>class <span class="ident">AbsReLUNode</span></span>
<span>(</span><span>identifier:str, ref_node:<a title="pynever.nodes.ReLUNode" href="../nodes.html#pynever.nodes.ReLUNode">ReLUNode</a>, heuristic:str, params:List)</span>
</code></dt>
<dd>
<div class="desc"><p>A class used for our internal representation of a ReLU Abstract transformer.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>identifier</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier of the LayerNode.</dd>
<dt><strong><code>ref_node</code></strong> :&ensp;<code>ReLUNode</code></dt>
<dd>Reference LayerNode for the abstract transformer.</dd>
<dt><strong><code>heuristic</code></strong> :&ensp;<code>str</code></dt>
<dd>Heuristic used to decide the refinement level of the abstraction.
At present can be only one of the following:
- given_flags: the neuron to be refined are selected referring to the list given in params
- best_n_neurons: for each star the n best neuron to refine are selected based on the loss of precision
the abstraction would incur using the coarse over_approximation.
- best_n_neurons_rel: for each star the n best neuron to refine are selected based on the loss of precision
the abstraction would incur using the coarse over_approximation together with the neuron relevances values.</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>List</code></dt>
<dd>Parameters for the heuristic of interest.
If the heuristic is given_flags then params is a List whose first element is the list of refinement flags.
If the heuristic is best_n_neurons then params is a List whose first element is the number of neurons to refine.
If the heuristic is best_n_neurons_rel then params is a List whose first element is a tuple containing
the number of neurons to refine and a list containing the relevances of the neurons.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>forward(AbsElement)
Function which takes an AbsElement and compute the corresponding output AbsElement based on the abstract
transformer.</p>
<p>backward(RefinementState)
Function which takes a reference to the refinement state and update both it and the state of the abstract
transformer to control the refinement component of the abstraction. At present the function is just a
placeholder for future implementations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsReLUNode(AbsLayerNode):
    &#34;&#34;&#34;
    A class used for our internal representation of a ReLU Abstract transformer.

    Attributes
    ----------
    identifier : str
        Identifier of the LayerNode.

    ref_node : ReLUNode
        Reference LayerNode for the abstract transformer.

    heuristic : str
        Heuristic used to decide the refinement level of the abstraction.
        At present can be only one of the following:
        - given_flags: the neuron to be refined are selected referring to the list given in params
        - best_n_neurons: for each star the n best neuron to refine are selected based on the loss of precision
          the abstraction would incur using the coarse over_approximation.
        - best_n_neurons_rel: for each star the n best neuron to refine are selected based on the loss of precision
          the abstraction would incur using the coarse over_approximation together with the neuron relevances values.

    params : List
        Parameters for the heuristic of interest.
        If the heuristic is given_flags then params is a List whose first element is the list of refinement flags.
        If the heuristic is best_n_neurons then params is a List whose first element is the number of neurons to refine.
        If the heuristic is best_n_neurons_rel then params is a List whose first element is a tuple containing
        the number of neurons to refine and a list containing the relevances of the neurons.

    Methods
    ----------
    forward(AbsElement)
        Function which takes an AbsElement and compute the corresponding output AbsElement based on the abstract
        transformer.

    backward(RefinementState)
        Function which takes a reference to the refinement state and update both it and the state of the abstract
        transformer to control the refinement component of the abstraction. At present the function is just a
        placeholder for future implementations.
    &#34;&#34;&#34;

    def __init__(self, identifier: str, ref_node: nodes.ReLUNode, heuristic: str, params: List):

        super().__init__(identifier, ref_node)

        self.heuristic = heuristic
        self.params = params
        self.n_areas = None

    def forward(self, abs_input: AbsElement) -&gt; AbsElement:
        &#34;&#34;&#34;
        Compute the output AbsElement based on the input AbsElement and the characteristics of the
        concrete abstract transformer.

        Parameters
        ----------
        abs_input : AbsElement
            The input abstract element.

        Returns
        ----------
        AbsElement
            The AbsElement resulting from the computation corresponding to the abstract transformer.
        &#34;&#34;&#34;

        if isinstance(abs_input, StarSet):
            if parallel:
                return self.__parallel_starset_forward(abs_input)
            else:
                return self.__starset_forward(abs_input)
        else:
            raise NotImplementedError

    def backward(self, ref_state: RefinementState):
        &#34;&#34;&#34;
        Update the RefinementState. At present the function is just a placeholder for future implementations.

        Parameters
        ----------
        ref_state: RefinementState
            The RefinementState to update.
        &#34;&#34;&#34;
        pass

    def __parallel_starset_forward(self, abs_input: StarSet) -&gt; StarSet:

        my_pool = multiprocessing.Pool(multiprocessing.cpu_count())
        parallel_results = my_pool.starmap(mixed_single_relu_forward, zip(abs_input.stars,
                                                                          itertools.repeat(self.heuristic),
                                                                          itertools.repeat(self.params)))
        my_pool.close()

        abs_output = StarSet()

        tot_areas = np.zeros(self.ref_node.in_dim)
        num_areas = 0
        for star_set, areas in parallel_results:
            if star_set != set():
                num_areas = num_areas + 1
                tot_areas = tot_areas + areas
            abs_output.stars = abs_output.stars.union(star_set)

        self.n_areas = tot_areas / num_areas

        return abs_output

    def __starset_forward(self, abs_input: StarSet) -&gt; StarSet:
        &#34;&#34;&#34;
        Forward function specialized for the concrete AbsElement StarSet.
        &#34;&#34;&#34;

        abs_output = StarSet()
        tot_areas = np.zeros(self.ref_node.in_dim)
        num_areas = 0
        for star in abs_input.stars:

            result, areas = mixed_single_relu_forward(star, self.heuristic, self.params)
            abs_output.stars = abs_output.stars.union(result)
            tot_areas = tot_areas + areas
            num_areas = num_areas + 1

        self.n_areas = tot_areas / num_areas

        return abs_output</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pynever.strategies.abstraction.AbsLayerNode" href="#pynever.strategies.abstraction.AbsLayerNode">AbsLayerNode</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pynever.strategies.abstraction.AbsLayerNode" href="#pynever.strategies.abstraction.AbsLayerNode">AbsLayerNode</a></b></code>:
<ul class="hlist">
<li><code><a title="pynever.strategies.abstraction.AbsLayerNode.backward" href="#pynever.strategies.abstraction.AbsLayerNode.backward">backward</a></code></li>
<li><code><a title="pynever.strategies.abstraction.AbsLayerNode.forward" href="#pynever.strategies.abstraction.AbsLayerNode.forward">forward</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pynever.strategies.abstraction.AbsSeqNetwork"><code class="flex name class">
<span>class <span class="ident">AbsSeqNetwork</span></span>
<span>(</span><span>identifier:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Concrete children of AbsNeuralNetwork representing a sequential AbsNeuralNetwork.
It consists of a graph of LayerNodes. The computational graph of a SequentialNetwork must
correspond to a standard list. The method forward and backward calls the corresponding methods
in the AbsLayerNodes following the correct order to compute the output AbsElement.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>identifier</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier of the Sequential AbsNeuralNetwork.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>add_node(LayerNode)
Procedure to add a new AbsLayerNode to the sequential AbsNeuralNetwork.</p>
<p>get_first_node()
Procedure to extract the first AbsLayerNode of the sequential AbsNeuralNetwork.</p>
<p>get_next_node(LayerNode)
Procedure to get the next AbsLayerNode of the AbsNeuralNetwork given an input AbsLayerNode</p>
<p>get_last_node()
Procedure to extract the last AbsLayerNode of the sequential AbsNeuralNetwork.</p>
<p>forward(AbsElement)
Function which takes an AbsElement and compute the corresponding output AbsElement based on the AbsLayerNode
of the network.</p>
<p>backward(RefinementState)
Function which takes a reference to the refinement state and update both it and the state of the AbsLayerNodes
to control the refinement component of the abstraction. At present the function is just a placeholder for
future implementations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsSeqNetwork(AbsNeuralNetwork):
    &#34;&#34;&#34;
    Concrete children of AbsNeuralNetwork representing a sequential AbsNeuralNetwork.
    It consists of a graph of LayerNodes. The computational graph of a SequentialNetwork must
    correspond to a standard list. The method forward and backward calls the corresponding methods
    in the AbsLayerNodes following the correct order to compute the output AbsElement.

    Attributes
    ----------
    identifier : str
        Identifier of the Sequential AbsNeuralNetwork.

    Methods
    -------
    add_node(LayerNode)
        Procedure to add a new AbsLayerNode to the sequential AbsNeuralNetwork.

    get_first_node()
        Procedure to extract the first AbsLayerNode of the sequential AbsNeuralNetwork.

    get_next_node(LayerNode)
        Procedure to get the next AbsLayerNode of the AbsNeuralNetwork given an input AbsLayerNode

    get_last_node()
        Procedure to extract the last AbsLayerNode of the sequential AbsNeuralNetwork.

    forward(AbsElement)
        Function which takes an AbsElement and compute the corresponding output AbsElement based on the AbsLayerNode
        of the network.

    backward(RefinementState)
        Function which takes a reference to the refinement state and update both it and the state of the AbsLayerNodes
        to control the refinement component of the abstraction. At present the function is just a placeholder for
        future implementations.

    &#34;&#34;&#34;

    def __init__(self, identifier: str):

        super().__init__()
        self.identifier = identifier

    def add_node(self, node: AbsLayerNode):
        &#34;&#34;&#34;
        Procedure to add a new AbsLayerNode. In sequential network the new node must be connected directly to the
        previous node forming a list.

        Parameters
        ----------
        node : AbsLayerNode
            New node to add to the Sequential network.

        &#34;&#34;&#34;

        if len(self.nodes.keys()) == 0:
            self.nodes[node.identifier] = node
            self.edges[node.identifier] = []
        else:
            previous_node_key = self.get_last_node().identifier
            self.nodes[node.identifier] = node
            self.edges[previous_node_key].append(node.identifier)
            self.edges[node.identifier] = []

    def get_first_node(self) -&gt; AbsLayerNode:
        &#34;&#34;&#34;
        Procedure to get the first AbsLayerNode of the network.

        Return
        ---------
        AbsLayerNode
            The first node of the network.

        &#34;&#34;&#34;
        assert self.nodes

        keys = [key for key in self.nodes.keys()]
        for key in self.nodes.keys():
            for sub_key in self.nodes.keys():
                if sub_key in self.edges[key]:
                    keys.remove(sub_key)

        return self.nodes[keys[0]]

    def get_next_node(self, node: AbsLayerNode) -&gt; AbsLayerNode:
        &#34;&#34;&#34;
        Procedure to get the next AbsLayerNode of the network given an input AbsLayerNode.

        Return
        ---------
        LayerNode
            The next node of the network.

        &#34;&#34;&#34;

        assert self.nodes

        next_node = None
        if node is not None:
            current_key = node.identifier
            if len(self.edges[current_key]) != 0:
                next_key = self.edges[current_key][0]
                next_node = self.nodes[next_key]
        else:
            next_node = self.get_first_node()

        return next_node

    def get_last_node(self) -&gt; AbsLayerNode:
        &#34;&#34;&#34;
        Procedure to get the last AbsLayerNode of the network.

        Return
        ---------
        AbsLayerNode
            The last node of the network.

        &#34;&#34;&#34;

        assert self.nodes

        current_node = self.get_first_node()
        while self.get_next_node(current_node) is not None:
            current_node = self.get_next_node(current_node)

        return current_node

    def forward(self, abs_input: AbsElement) -&gt; AbsElement:
        &#34;&#34;&#34;
        Compute the output AbsElement based on the input AbsElement and the characteristics of the
        concrete abstract transformers.

        Parameters
        ----------
        abs_input : AbsElement
            The input abstract element.

        Returns
        ----------
        AbsElement
            The AbsElement resulting from the computation corresponding to the abstract transformer.
        &#34;&#34;&#34;

        current_node = self.get_first_node()
        while current_node is not None:
            abs_input = current_node.forward(abs_input)
            current_node = self.get_next_node(current_node)

        return abs_input

    def backward(self, ref_state: RefinementState):
        &#34;&#34;&#34;
        Update the RefinementState. At present the function is just a placeholder for future implementations.

        Parameters
        ----------
        ref_state: RefinementState
            The RefinementState to update.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pynever.strategies.abstraction.AbsNeuralNetwork" href="#pynever.strategies.abstraction.AbsNeuralNetwork">AbsNeuralNetwork</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pynever.strategies.abstraction.AbsSeqNetwork.add_node"><code class="name flex">
<span>def <span class="ident">add_node</span></span>(<span>self, node:<a title="pynever.strategies.abstraction.AbsLayerNode" href="#pynever.strategies.abstraction.AbsLayerNode">AbsLayerNode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Procedure to add a new AbsLayerNode. In sequential network the new node must be connected directly to the
previous node forming a list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code><a title="pynever.strategies.abstraction.AbsLayerNode" href="#pynever.strategies.abstraction.AbsLayerNode">AbsLayerNode</a></code></dt>
<dd>New node to add to the Sequential network.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_node(self, node: AbsLayerNode):
    &#34;&#34;&#34;
    Procedure to add a new AbsLayerNode. In sequential network the new node must be connected directly to the
    previous node forming a list.

    Parameters
    ----------
    node : AbsLayerNode
        New node to add to the Sequential network.

    &#34;&#34;&#34;

    if len(self.nodes.keys()) == 0:
        self.nodes[node.identifier] = node
        self.edges[node.identifier] = []
    else:
        previous_node_key = self.get_last_node().identifier
        self.nodes[node.identifier] = node
        self.edges[previous_node_key].append(node.identifier)
        self.edges[node.identifier] = []</code></pre>
</details>
</dd>
<dt id="pynever.strategies.abstraction.AbsSeqNetwork.get_first_node"><code class="name flex">
<span>def <span class="ident">get_first_node</span></span>(<span>self) ><a title="pynever.strategies.abstraction.AbsLayerNode" href="#pynever.strategies.abstraction.AbsLayerNode">AbsLayerNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Procedure to get the first AbsLayerNode of the network.</p>
<h2 id="return">Return</h2>
<p>AbsLayerNode
The first node of the network.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_first_node(self) -&gt; AbsLayerNode:
    &#34;&#34;&#34;
    Procedure to get the first AbsLayerNode of the network.

    Return
    ---------
    AbsLayerNode
        The first node of the network.

    &#34;&#34;&#34;
    assert self.nodes

    keys = [key for key in self.nodes.keys()]
    for key in self.nodes.keys():
        for sub_key in self.nodes.keys():
            if sub_key in self.edges[key]:
                keys.remove(sub_key)

    return self.nodes[keys[0]]</code></pre>
</details>
</dd>
<dt id="pynever.strategies.abstraction.AbsSeqNetwork.get_last_node"><code class="name flex">
<span>def <span class="ident">get_last_node</span></span>(<span>self) ><a title="pynever.strategies.abstraction.AbsLayerNode" href="#pynever.strategies.abstraction.AbsLayerNode">AbsLayerNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Procedure to get the last AbsLayerNode of the network.</p>
<h2 id="return">Return</h2>
<p>AbsLayerNode
The last node of the network.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_last_node(self) -&gt; AbsLayerNode:
    &#34;&#34;&#34;
    Procedure to get the last AbsLayerNode of the network.

    Return
    ---------
    AbsLayerNode
        The last node of the network.

    &#34;&#34;&#34;

    assert self.nodes

    current_node = self.get_first_node()
    while self.get_next_node(current_node) is not None:
        current_node = self.get_next_node(current_node)

    return current_node</code></pre>
</details>
</dd>
<dt id="pynever.strategies.abstraction.AbsSeqNetwork.get_next_node"><code class="name flex">
<span>def <span class="ident">get_next_node</span></span>(<span>self, node:<a title="pynever.strategies.abstraction.AbsLayerNode" href="#pynever.strategies.abstraction.AbsLayerNode">AbsLayerNode</a>) ><a title="pynever.strategies.abstraction.AbsLayerNode" href="#pynever.strategies.abstraction.AbsLayerNode">AbsLayerNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Procedure to get the next AbsLayerNode of the network given an input AbsLayerNode.</p>
<h2 id="return">Return</h2>
<p>LayerNode
The next node of the network.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_next_node(self, node: AbsLayerNode) -&gt; AbsLayerNode:
    &#34;&#34;&#34;
    Procedure to get the next AbsLayerNode of the network given an input AbsLayerNode.

    Return
    ---------
    LayerNode
        The next node of the network.

    &#34;&#34;&#34;

    assert self.nodes

    next_node = None
    if node is not None:
        current_key = node.identifier
        if len(self.edges[current_key]) != 0:
            next_key = self.edges[current_key][0]
            next_node = self.nodes[next_key]
    else:
        next_node = self.get_first_node()

    return next_node</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pynever.strategies.abstraction.AbsNeuralNetwork" href="#pynever.strategies.abstraction.AbsNeuralNetwork">AbsNeuralNetwork</a></b></code>:
<ul class="hlist">
<li><code><a title="pynever.strategies.abstraction.AbsNeuralNetwork.backward" href="#pynever.strategies.abstraction.AbsNeuralNetwork.backward">backward</a></code></li>
<li><code><a title="pynever.strategies.abstraction.AbsNeuralNetwork.forward" href="#pynever.strategies.abstraction.AbsNeuralNetwork.forward">forward</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pynever.strategies.abstraction.AbsSigmoidNode"><code class="flex name class">
<span>class <span class="ident">AbsSigmoidNode</span></span>
<span>(</span><span>identifier:str, ref_node:<a title="pynever.nodes.SigmoidNode" href="../nodes.html#pynever.nodes.SigmoidNode">SigmoidNode</a>, approx_levels:Union[int,List[int]]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class used for our internal representation of a Sigmoid transformer.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>identifier</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier of the LayerNode.</dd>
<dt><strong><code>ref_node</code></strong> :&ensp;<code>SigmoidNode</code></dt>
<dd>LayerNode di riferimento per l'abstract transformer.</dd>
<dt><strong><code>refinement_level</code></strong> :&ensp;<code>Union[int, List[int]]</code></dt>
<dd>Refinement level for the sigmoid nodes: if it is a single int then that refinement level is applied to all
the neurons of the layers, otherwise it is a list containing the refinement levels for each layers.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>forward(AbsElement)
Function which takes an AbsElement and compute the corresponding output AbsElement based on the abstract
transformer.</p>
<p>backward(RefinementState)
Function which takes a reference to the refinement state and update both it and the state of the abstract
transformer to control the refinement component of the abstraction. At present the function is just a
placeholder for future implementations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbsSigmoidNode(AbsLayerNode):
    &#34;&#34;&#34;
    A class used for our internal representation of a Sigmoid transformer.

    Attributes
    ----------
    identifier : str
        Identifier of the LayerNode.

    ref_node : SigmoidNode
        LayerNode di riferimento per l&#39;abstract transformer.

    refinement_level : Union[int, List[int]]
        Refinement level for the sigmoid nodes: if it is a single int then that refinement level is applied to all
        the neurons of the layers, otherwise it is a list containing the refinement levels for each layers.

    Methods
    ----------
    forward(AbsElement)
        Function which takes an AbsElement and compute the corresponding output AbsElement based on the abstract
        transformer.

    backward(RefinementState)
        Function which takes a reference to the refinement state and update both it and the state of the abstract
        transformer to control the refinement component of the abstraction. At present the function is just a
        placeholder for future implementations.
    &#34;&#34;&#34;

    def __init__(self, identifier: str, ref_node: nodes.SigmoidNode, approx_levels: Union[int, List[int]] = None):
        super().__init__(identifier, ref_node)

        if approx_levels is None:
            approx_levels = [0 for i in range(ref_node.in_dim[-1])]
        elif isinstance(approx_levels, int):
            approx_levels = [approx_levels for i in range(ref_node.in_dim[-1])]

        self.approx_levels = approx_levels

    def forward(self, abs_input: AbsElement) -&gt; AbsElement:
        &#34;&#34;&#34;
        Compute the output AbsElement based on the input AbsElement and the characteristics of the
        concrete abstract transformer.

        Parameters
        ----------
        abs_input : AbsElement
            The input abstract element.

        Returns
        ----------
        AbsElement
            The AbsElement resulting from the computation corresponding to the abstract transformer.
        &#34;&#34;&#34;
        if isinstance(abs_input, StarSet):
            return self.__starset_forward(abs_input)
        else:
            raise NotImplementedError

    def __starset_forward(self, abs_input: StarSet) -&gt; StarSet:

        #parallel = True
        if parallel:
            abs_output = StarSet()
            my_pool = multiprocessing.Pool(1)
            parallel_results = my_pool.starmap(single_sigmoid_forward, zip(abs_input.stars,
                                                                           itertools.repeat(self.approx_levels)))
            my_pool.close()
            for star_set in parallel_results:
                abs_output.stars = abs_output.stars.union(star_set)
        else:
            abs_output = StarSet()
            for star in abs_input.stars:
                abs_output.stars = abs_output.stars.union(single_sigmoid_forward(star, self.approx_levels))

        return abs_output

    def backward(self, ref_state: RefinementState):
        &#34;&#34;&#34;
        Update the RefinementState. At present the function is just a placeholder for future implementations.

        Parameters
        ----------
        ref_state: RefinementState
            The RefinementState to update.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pynever.strategies.abstraction.AbsLayerNode" href="#pynever.strategies.abstraction.AbsLayerNode">AbsLayerNode</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pynever.strategies.abstraction.AbsLayerNode" href="#pynever.strategies.abstraction.AbsLayerNode">AbsLayerNode</a></b></code>:
<ul class="hlist">
<li><code><a title="pynever.strategies.abstraction.AbsLayerNode.backward" href="#pynever.strategies.abstraction.AbsLayerNode.backward">backward</a></code></li>
<li><code><a title="pynever.strategies.abstraction.AbsLayerNode.forward" href="#pynever.strategies.abstraction.AbsLayerNode.forward">forward</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pynever.strategies.abstraction.RefinementState"><code class="flex name class">
<span>class <span class="ident">RefinementState</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class used for the internal control of the refinement strategies/heuristics applied in the abstraction refinement
step. At present is not still used and it is just an abstract placeholder. It will be used in future
implementations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RefinementState(abc.ABC):
    &#34;&#34;&#34;
    A class used for the internal control of the refinement strategies/heuristics applied in the abstraction refinement
    step. At present is not still used and it is just an abstract placeholder. It will be used in future
    implementations.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
</dd>
<dt id="pynever.strategies.abstraction.Star"><code class="flex name class">
<span>class <span class="ident">Star</span></span>
<span>(</span><span>predicate_matrix:<a title="pynever.tensor.Tensor" href="../tensor.html#pynever.tensor.Tensor">Tensor</a>, predicate_bias:<a title="pynever.tensor.Tensor" href="../tensor.html#pynever.tensor.Tensor">Tensor</a>, center:<a title="pynever.tensor.Tensor" href="../tensor.html#pynever.tensor.Tensor">Tensor</a>=None, basis_matrix:<a title="pynever.tensor.Tensor" href="../tensor.html#pynever.tensor.Tensor">Tensor</a>=None, lbs:list=None, ubs:list=None, is_empty:bool=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A concrete class used for our internal representation of a Star.
The Star is defined as {x | x = c + Va such that Ca &lt;= d}
where c is a n-dimensional vector corresponding to the center of the Star.
V is the n-by-m matrix composed by the basis vectors.
a is the vector of m variables, C (p-by-m) and d (p-dim) are the matrix and the biases
defining a set of constraints.</p>
<p>We refer to <Star-Based Reachability Analysis of Deep Neural Networks>
(<a href="https://link.springer.com/chapter/10.1007/978-3-030-30942-8_39">https://link.springer.com/chapter/10.1007/978-3-030-30942-8_39</a>) for details.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>center</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Center of the Star.</dd>
<dt><strong><code>basis_matrix</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Matrix composed by the basis vectors of the Star</dd>
<dt><strong><code>predicate_matrix</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Matrix of the Predicate.</dd>
<dt><strong><code>predicate_bias</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Bias of the Predicate.</dd>
<dt><strong><code>ubs</code></strong> :&ensp;<code>list</code></dt>
<dd>Upper bounds of the points defined by the Star.</dd>
<dt><strong><code>lbs</code></strong> :&ensp;<code>list</code></dt>
<dd>Lower bounds of the points defined by the Star.</dd>
<dt><strong><code>is_empty</code></strong> :&ensp;<code>bool</code></dt>
<dd>Boolean flag: True if the Star defines an empty set of points, False otherwise</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_bounds()
Function used to get the upper and lower bounds of the n variables of the star.
check_if_empty()
Function used to check if the star corresponds to an empty set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Star:
    &#34;&#34;&#34;
    A concrete class used for our internal representation of a Star.
    The Star is defined as {x | x = c + Va such that Ca &lt;= d}
    where c is a n-dimensional vector corresponding to the center of the Star.
    V is the n-by-m matrix composed by the basis vectors.
    a is the vector of m variables, C (p-by-m) and d (p-dim) are the matrix and the biases
    defining a set of constraints.

    We refer to &lt;Star-Based Reachability Analysis of Deep Neural Networks&gt;
    (https://link.springer.com/chapter/10.1007/978-3-030-30942-8_39) for details.

    Attributes
    ----------
    center : Tensor
        Center of the Star.
    basis_matrix : Tensor
        Matrix composed by the basis vectors of the Star
    predicate_matrix : Tensor
        Matrix of the Predicate.
    predicate_bias : Tensor
        Bias of the Predicate.
    ubs : list
        Upper bounds of the points defined by the Star.
    lbs : list
        Lower bounds of the points defined by the Star.
    is_empty : bool
        Boolean flag: True if the Star defines an empty set of points, False otherwise

    Methods
    ----------
    get_bounds()
        Function used to get the upper and lower bounds of the n variables of the star.
    check_if_empty()
        Function used to check if the star corresponds to an empty set.


    &#34;&#34;&#34;

    def __init__(self, predicate_matrix: Tensor, predicate_bias: Tensor, center: Tensor = None,
                 basis_matrix: Tensor = None, lbs: list = None, ubs: list = None, is_empty: bool = None):

        predicate_dim_message = f&#34;Error: the first dimension of the predicate_matrix ({predicate_matrix.shape[0]}) &#34; \
                                f&#34;must be equal to the dimension of the predicate_bias ({predicate_bias.shape[0]}).&#34;
        assert predicate_matrix.shape[0] == predicate_bias.shape[0], predicate_dim_message

        self.predicate_matrix = predicate_matrix
        self.predicate_bias = predicate_bias

        if center is None and basis_matrix is None:
            self.center = np.zeros((predicate_matrix.shape[1], 1))
            self.basis_matrix = np.identity(predicate_matrix.shape[1])

        else:
            center_dim_message = f&#34;Error: the first dimension of the basis_matrix ({basis_matrix.shape[0]}) &#34; \
                                 f&#34;must be equal to the dimension of the center ({center.shape[0]}).&#34;
            assert center.shape[0] == basis_matrix.shape[0], center_dim_message

            basis_dim_message = f&#34;Error: the second dimension of the basis_matrix ({basis_matrix.shape[1]}) &#34; \
                                f&#34;must be equal to the second dimension of the predicate_matrix &#34; \
                                f&#34;({predicate_matrix.shape[1]}).&#34;
            assert basis_matrix.shape[1] == predicate_matrix.shape[1], basis_dim_message

            self.center = center
            self.basis_matrix = basis_matrix

        if lbs is None:
            lbs = [None for i in range(self.center.shape[0])]

        if ubs is None:
            ubs = [None for i in range(self.center.shape[0])]

        self.lbs = lbs
        self.ubs = ubs
        self.is_empty = is_empty

        # Private Attributes used for the sampling of the star.
        self.__auxiliary_points = None
        self.__current_point = None

    def check_if_empty(self) -&gt; bool:
        &#34;&#34;&#34;
        Function used to check if the set of points defined by the star is empty.

        Return
        ---------
        bool
            True if the star defines an empty set of points, False otherwise.
        &#34;&#34;&#34;

        start_time = time.perf_counter()
        if self.is_empty is None:

            solver, alphas, constraints = self.__get_predicate_lp_solver()
            objective = solver.Objective()
            for j in range(self.predicate_matrix.shape[1]):
                objective.SetCoefficient(alphas[j], 0)
            objective.SetOffset(0)

            objective.SetMinimization()
            status = solver.Solve()
            if status == pywraplp.Solver.INFEASIBLE or status == pywraplp.Solver.ABNORMAL:
                self.is_empty = True
            else:
                self.is_empty = False

        end_time = time.perf_counter()
        logger_empty.debug(f&#34;{end_time - start_time},&#34;)

        return self.is_empty

    def get_bounds(self, i) -&gt; (float, float):
        &#34;&#34;&#34;
        Function used to get the upper and lower bounds of the n variables of the star.

        Return
        ---------
        (float, float)
            Tuple containing the lower and upper bounds of the variable i of the star
        &#34;&#34;&#34;

        if self.lbs[i] is None or self.ubs[i] is None or self.is_empty is None:

            # print(&#34;Computing bounds&#34;)
            start_time = time.perf_counter()

            solver, alphas, constraints = self.__get_predicate_lp_solver()
            objective = solver.Objective()
            for j in range(self.basis_matrix.shape[1]):
                objective.SetCoefficient(alphas[j], self.basis_matrix[i, j])
            objective.SetOffset(self.center[i, 0])

            objective.SetMinimization()

            lb_start = time.perf_counter()
            status = solver.Solve()
            lb_end = time.perf_counter()

            assert status == pywraplp.Solver.OPTIMAL, &#34;The LP problem was not Optimal&#34;

            if status == pywraplp.Solver.INFEASIBLE or status == pywraplp.Solver.ABNORMAL:
                self.is_empty = True
                self.lbs[i] = None
                self.ubs[i] = None
                ub_end = 0
                ub_start = 0
            else:
                self.is_empty = False

                lb = solver.Objective().Value()
                objective.SetMaximization()
                ub_start = time.perf_counter()
                status = solver.Solve()
                ub_end = time.perf_counter()
                ub = solver.Objective().Value()

                self.lbs[i] = lb
                self.ubs[i] = ub

            end_time = time.perf_counter()

            logger_lp.debug(f&#34;{end_time - start_time},&#34;)
            logger_lb.debug(f&#34;{ub_end - ub_start},&#34;)
            logger_ub.debug(f&#34;{lb_end - lb_start},&#34;)

        return self.lbs[i], self.ubs[i]

    def check_alpha_inside(self, alpha_point: Tensor) -&gt; bool:
        &#34;&#34;&#34;
        Function which checks if the alpha point passed as input is valid with respect to the constraints defined by the
        predicate matrix and bias of the star.

        Parameters
        ----------
        alpha_point : Tensor
            Point (with respect ot the predicate variables) whose validity is to test.

        Returns
        -------
        bool
            The result of the check as a boolean (True if the point is valid, False otherwise)
        &#34;&#34;&#34;

        dim_error_msg = f&#34;Wrong dimensionality for alpha_point: it should be {self.predicate_matrix.shape[1]} by one.&#34;
        assert alpha_point.shape[0] == self.predicate_matrix.shape[1], dim_error_msg
        tests = np.matmul(self.predicate_matrix, alpha_point) &lt;= self.predicate_bias
        test = np.all(tests)
        return test

    def check_point_inside(self, point: Tensor, epsilon: float) -&gt; bool:
        &#34;&#34;&#34;
        Function which checks if the point passed as input is valid with respect to the constraints defined by the
        predicate matrix and bias of the star.

        Parameters
        ----------
        point : Tensor
            Point whose validity is to test.
        epsilon : float
            Acceptable deviation from real point.

        Returns
        -------
        bool
            The result of the check as a boolean (True if the point is valid, False otherwise)

        &#34;&#34;&#34;

        solver = pywraplp.Solver.CreateSolver(&#39;GLOP&#39;)
        alphas = []
        for j in range(self.basis_matrix.shape[1]):
            new_alpha = solver.NumVar(-solver.infinity(), solver.infinity(), f&#39;alpha_{j}&#39;)
            alphas.append(new_alpha)

        constraints = []
        for k in range(self.predicate_matrix.shape[0]):
            new_constraint = solver.Constraint(-solver.infinity(), self.predicate_bias[k, 0])
            for j in range(self.predicate_matrix.shape[1]):
                new_constraint.SetCoefficient(alphas[j], self.predicate_matrix[k, j])
            constraints.append(new_constraint)

        for i in range(self.basis_matrix.shape[0]):
            lb = point[i][0] - self.center[i][0] - epsilon
            ub = point[i][0] - self.center[i][0] + epsilon
            new_constraint = solver.Constraint(lb, ub)
            for j in range(self.basis_matrix.shape[1]):
                new_constraint.SetCoefficient(alphas[j], self.basis_matrix[i, j])
            constraints.append(new_constraint)

        objective = solver.Objective()
        for j in range(self.predicate_matrix.shape[1]):
            objective.SetCoefficient(alphas[j], 0)
        objective.SetOffset(0)

        objective.SetMinimization()
        status = solver.Solve()

        return status == pywraplp.Solver.FEASIBLE or status == pywraplp.Solver.OPTIMAL

    def get_samples(self, num_samples: int, reset_auxiliary: bool = False, new_start: bool = False) -&gt; List[Tensor]:

        # As first thing we need to get a valid starting point:
        # assert not self.check_if_empty(), &#34;Empty Set: impossible to sample.&#34;
        if self.check_if_empty():
            return []

        if self.__auxiliary_points is None or reset_auxiliary:
            auxiliary_points = self.__get_auxiliary_points()
        else:
            auxiliary_points = self.__auxiliary_points

        if self.__current_point is None or new_start:
            starting_point = self.__get_starting_point()
            current_point = np.array(starting_point)
        else:
            current_point = self.__current_point

        # We begin the iterative process to generate the samples of interest.
        samples = []
        while len(samples) &lt; num_samples:

            direction = np.random.randn(self.predicate_matrix.shape[1], 1)
            direction = direction / dist.norm(direction)
            lambdas = []
            for i in range(self.predicate_matrix.shape[0]):
                if np.isclose(np.matmul(self.predicate_matrix[i, :], direction), 0):
                    lambdas.append(np.nan)
                else:
                    temp = auxiliary_points[i] - current_point
                    lam = np.matmul(self.predicate_matrix[i, :], temp) / (np.matmul(self.predicate_matrix[i, :],
                                                                                    direction))
                    lambdas.append(lam)
            lambdas = np.array(lambdas)

            try:
                lam_upper = np.min(lambdas[lambdas &gt;= 0])
                lam_lower = np.max(lambdas[lambdas &lt; 0])
            except Exception:
                raise RuntimeError(&#34;The current direction does not intersect&#34;
                                   &#34;any of the hyperplanes.&#34;)

            increment = np.random.uniform(low=lam_lower, high=lam_upper)
            next_point = current_point + increment * direction
            if self.check_alpha_inside(next_point):
                current_point = next_point
                star_point = self.center + np.matmul(self.basis_matrix, current_point)
                samples.append(star_point)
                self.__current_point = current_point

        return samples

    def __get_auxiliary_points(self) -&gt; List[Tensor]:
        &#34;&#34;&#34;
        Function which returns the auxiliary points for each plane of the predicate.

        Returns
        -------
        List[Tensor]
            List of the auxiliary points: one for each plane of the predicate.

        &#34;&#34;&#34;
        aux_points = []
        for i in range(self.predicate_matrix.shape[0]):
            p = np.zeros((self.predicate_matrix.shape[1], 1))
            plane = self.predicate_matrix[i, :]
            max_nonzero_index = np.argmax(np.where(plane != 0, plane, -np.inf))
            p[max_nonzero_index] = self.predicate_bias[i] / plane[max_nonzero_index]
            aux_points.append(p)

        return aux_points

    def __get_starting_point_by_bounds(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Function used to get the starting point for the hit and run algorithm.

        Return
        ---------
        (float, float)
            Tuple containing the lower and upper bounds of the variables of the predicate
        &#34;&#34;&#34;

        starting_point = []
        for i in range(self.predicate_matrix.shape[1]):

            solver, alphas, constraints = self.__get_predicate_lp_solver()
            objective = solver.Objective()
            for j in range(self.predicate_matrix.shape[1]):
                if j == i:
                    objective.SetCoefficient(alphas[j], 1)
                else:
                    objective.SetCoefficient(alphas[j], 0)

            objective.SetMinimization()
            status = solver.Solve()

            assert status == pywraplp.Solver.OPTIMAL, &#34;The LP problem was not Optimal&#34;

            lb = solver.Objective().Value()

            objective.SetMaximization()
            status = solver.Solve()

            assert status == pywraplp.Solver.OPTIMAL, &#34;The LP problem was not Optimal&#34;

            ub = solver.Objective().Value()

            starting_point.append([(lb + ub) / 2.0])

        starting_point = np.array(starting_point)
        return starting_point

    def __get_starting_point(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Function used to get the starting point for the hit and run algorithm.

        Return
        ---------
        (float, float)
            Tuple containing the lower and upper bounds of the variables of the predicate
        &#34;&#34;&#34;
        starting_point = []

        solver = pywraplp.Solver.CreateSolver(&#39;GLOP&#39;)
        alphas = []
        for j in range(self.basis_matrix.shape[1]):
            new_alpha = solver.NumVar(-solver.infinity(), solver.infinity(), f&#39;alpha_{j}&#39;)
            alphas.append(new_alpha)
        radius = solver.NumVar(0, solver.infinity(), &#39;radius&#39;)

        constraints = []
        for k in range(self.predicate_matrix.shape[0]):
            new_constraint = solver.Constraint(-solver.infinity(), self.predicate_bias[k, 0])
            for j in range(self.predicate_matrix.shape[1]):
                new_constraint.SetCoefficient(alphas[j], self.predicate_matrix[k, j])
            new_constraint.SetCoefficient(radius, np.linalg.norm(self.predicate_matrix[k, :], 2))
            constraints.append(new_constraint)

        objective = solver.Objective()
        for j in range(self.predicate_matrix.shape[1]):
            objective.SetCoefficient(alphas[j], 0)
        objective.SetCoefficient(radius, 1)

        objective.SetMaximization()
        status = solver.Solve()

        assert status == pywraplp.Solver.OPTIMAL, &#34;It was impossible to compute the Chebyshev center of the predicate.&#34;

        for alpha in alphas:
            #print(alpha.solution_value())
            starting_point.append([alpha.solution_value()])
        #print(radius.solution_value())

        starting_point = np.array(starting_point)

        return starting_point

    def __get_predicate_lp_solver(self) -&gt; (pywraplp.Solver, list, list):
        &#34;&#34;&#34;
        Creates an lp solver using pywraplp and adds the variables and constraints
        corresponding to the predicate of the star.

        Returns
        ---------
        (pywraplp.Solver, list, list)
            Respectively the lp solver, the variables and the constraints.
        &#34;&#34;&#34;

        solver = pywraplp.Solver.CreateSolver(&#39;GLOP&#39;)
        alphas = []
        for j in range(self.basis_matrix.shape[1]):
            new_alpha = solver.NumVar(-solver.infinity(), solver.infinity(), f&#39;alpha_{j}&#39;)
            alphas.append(new_alpha)

        constraints = []
        for k in range(self.predicate_matrix.shape[0]):
            new_constraint = solver.Constraint(-solver.infinity(), self.predicate_bias[k, 0])
            for j in range(self.predicate_matrix.shape[1]):
                new_constraint.SetCoefficient(alphas[j], self.predicate_matrix[k, j])
            constraints.append(new_constraint)

        return solver, alphas, constraints</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pynever.strategies.abstraction.Star.check_alpha_inside"><code class="name flex">
<span>def <span class="ident">check_alpha_inside</span></span>(<span>self, alpha_point:<a title="pynever.tensor.Tensor" href="../tensor.html#pynever.tensor.Tensor">Tensor</a>) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Function which checks if the alpha point passed as input is valid with respect to the constraints defined by the
predicate matrix and bias of the star.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>alpha_point</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Point (with respect ot the predicate variables) whose validity is to test.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>The result of the check as a boolean (True if the point is valid, False otherwise)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_alpha_inside(self, alpha_point: Tensor) -&gt; bool:
    &#34;&#34;&#34;
    Function which checks if the alpha point passed as input is valid with respect to the constraints defined by the
    predicate matrix and bias of the star.

    Parameters
    ----------
    alpha_point : Tensor
        Point (with respect ot the predicate variables) whose validity is to test.

    Returns
    -------
    bool
        The result of the check as a boolean (True if the point is valid, False otherwise)
    &#34;&#34;&#34;

    dim_error_msg = f&#34;Wrong dimensionality for alpha_point: it should be {self.predicate_matrix.shape[1]} by one.&#34;
    assert alpha_point.shape[0] == self.predicate_matrix.shape[1], dim_error_msg
    tests = np.matmul(self.predicate_matrix, alpha_point) &lt;= self.predicate_bias
    test = np.all(tests)
    return test</code></pre>
</details>
</dd>
<dt id="pynever.strategies.abstraction.Star.check_if_empty"><code class="name flex">
<span>def <span class="ident">check_if_empty</span></span>(<span>self) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Function used to check if the set of points defined by the star is empty.</p>
<h2 id="return">Return</h2>
<p>bool
True if the star defines an empty set of points, False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_if_empty(self) -&gt; bool:
    &#34;&#34;&#34;
    Function used to check if the set of points defined by the star is empty.

    Return
    ---------
    bool
        True if the star defines an empty set of points, False otherwise.
    &#34;&#34;&#34;

    start_time = time.perf_counter()
    if self.is_empty is None:

        solver, alphas, constraints = self.__get_predicate_lp_solver()
        objective = solver.Objective()
        for j in range(self.predicate_matrix.shape[1]):
            objective.SetCoefficient(alphas[j], 0)
        objective.SetOffset(0)

        objective.SetMinimization()
        status = solver.Solve()
        if status == pywraplp.Solver.INFEASIBLE or status == pywraplp.Solver.ABNORMAL:
            self.is_empty = True
        else:
            self.is_empty = False

    end_time = time.perf_counter()
    logger_empty.debug(f&#34;{end_time - start_time},&#34;)

    return self.is_empty</code></pre>
</details>
</dd>
<dt id="pynever.strategies.abstraction.Star.check_point_inside"><code class="name flex">
<span>def <span class="ident">check_point_inside</span></span>(<span>self, point:<a title="pynever.tensor.Tensor" href="../tensor.html#pynever.tensor.Tensor">Tensor</a>, epsilon:float) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Function which checks if the point passed as input is valid with respect to the constraints defined by the
predicate matrix and bias of the star.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Point whose validity is to test.</dd>
<dt><strong><code>epsilon</code></strong> :&ensp;<code>float</code></dt>
<dd>Acceptable deviation from real point.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>The result of the check as a boolean (True if the point is valid, False otherwise)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_point_inside(self, point: Tensor, epsilon: float) -&gt; bool:
    &#34;&#34;&#34;
    Function which checks if the point passed as input is valid with respect to the constraints defined by the
    predicate matrix and bias of the star.

    Parameters
    ----------
    point : Tensor
        Point whose validity is to test.
    epsilon : float
        Acceptable deviation from real point.

    Returns
    -------
    bool
        The result of the check as a boolean (True if the point is valid, False otherwise)

    &#34;&#34;&#34;

    solver = pywraplp.Solver.CreateSolver(&#39;GLOP&#39;)
    alphas = []
    for j in range(self.basis_matrix.shape[1]):
        new_alpha = solver.NumVar(-solver.infinity(), solver.infinity(), f&#39;alpha_{j}&#39;)
        alphas.append(new_alpha)

    constraints = []
    for k in range(self.predicate_matrix.shape[0]):
        new_constraint = solver.Constraint(-solver.infinity(), self.predicate_bias[k, 0])
        for j in range(self.predicate_matrix.shape[1]):
            new_constraint.SetCoefficient(alphas[j], self.predicate_matrix[k, j])
        constraints.append(new_constraint)

    for i in range(self.basis_matrix.shape[0]):
        lb = point[i][0] - self.center[i][0] - epsilon
        ub = point[i][0] - self.center[i][0] + epsilon
        new_constraint = solver.Constraint(lb, ub)
        for j in range(self.basis_matrix.shape[1]):
            new_constraint.SetCoefficient(alphas[j], self.basis_matrix[i, j])
        constraints.append(new_constraint)

    objective = solver.Objective()
    for j in range(self.predicate_matrix.shape[1]):
        objective.SetCoefficient(alphas[j], 0)
    objective.SetOffset(0)

    objective.SetMinimization()
    status = solver.Solve()

    return status == pywraplp.Solver.FEASIBLE or status == pywraplp.Solver.OPTIMAL</code></pre>
</details>
</dd>
<dt id="pynever.strategies.abstraction.Star.get_bounds"><code class="name flex">
<span>def <span class="ident">get_bounds</span></span>(<span>self, i) >(<class'float'>,<class'float'>)</span>
</code></dt>
<dd>
<div class="desc"><p>Function used to get the upper and lower bounds of the n variables of the star.</p>
<h2 id="return">Return</h2>
<p>(float, float)
Tuple containing the lower and upper bounds of the variable i of the star</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bounds(self, i) -&gt; (float, float):
    &#34;&#34;&#34;
    Function used to get the upper and lower bounds of the n variables of the star.

    Return
    ---------
    (float, float)
        Tuple containing the lower and upper bounds of the variable i of the star
    &#34;&#34;&#34;

    if self.lbs[i] is None or self.ubs[i] is None or self.is_empty is None:

        # print(&#34;Computing bounds&#34;)
        start_time = time.perf_counter()

        solver, alphas, constraints = self.__get_predicate_lp_solver()
        objective = solver.Objective()
        for j in range(self.basis_matrix.shape[1]):
            objective.SetCoefficient(alphas[j], self.basis_matrix[i, j])
        objective.SetOffset(self.center[i, 0])

        objective.SetMinimization()

        lb_start = time.perf_counter()
        status = solver.Solve()
        lb_end = time.perf_counter()

        assert status == pywraplp.Solver.OPTIMAL, &#34;The LP problem was not Optimal&#34;

        if status == pywraplp.Solver.INFEASIBLE or status == pywraplp.Solver.ABNORMAL:
            self.is_empty = True
            self.lbs[i] = None
            self.ubs[i] = None
            ub_end = 0
            ub_start = 0
        else:
            self.is_empty = False

            lb = solver.Objective().Value()
            objective.SetMaximization()
            ub_start = time.perf_counter()
            status = solver.Solve()
            ub_end = time.perf_counter()
            ub = solver.Objective().Value()

            self.lbs[i] = lb
            self.ubs[i] = ub

        end_time = time.perf_counter()

        logger_lp.debug(f&#34;{end_time - start_time},&#34;)
        logger_lb.debug(f&#34;{ub_end - ub_start},&#34;)
        logger_ub.debug(f&#34;{lb_end - lb_start},&#34;)

    return self.lbs[i], self.ubs[i]</code></pre>
</details>
</dd>
<dt id="pynever.strategies.abstraction.Star.get_samples"><code class="name flex">
<span>def <span class="ident">get_samples</span></span>(<span>self, num_samples:int, reset_auxiliary:bool=False, new_start:bool=False) >List[<a title="pynever.tensor.Tensor" href="../tensor.html#pynever.tensor.Tensor">Tensor</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_samples(self, num_samples: int, reset_auxiliary: bool = False, new_start: bool = False) -&gt; List[Tensor]:

    # As first thing we need to get a valid starting point:
    # assert not self.check_if_empty(), &#34;Empty Set: impossible to sample.&#34;
    if self.check_if_empty():
        return []

    if self.__auxiliary_points is None or reset_auxiliary:
        auxiliary_points = self.__get_auxiliary_points()
    else:
        auxiliary_points = self.__auxiliary_points

    if self.__current_point is None or new_start:
        starting_point = self.__get_starting_point()
        current_point = np.array(starting_point)
    else:
        current_point = self.__current_point

    # We begin the iterative process to generate the samples of interest.
    samples = []
    while len(samples) &lt; num_samples:

        direction = np.random.randn(self.predicate_matrix.shape[1], 1)
        direction = direction / dist.norm(direction)
        lambdas = []
        for i in range(self.predicate_matrix.shape[0]):
            if np.isclose(np.matmul(self.predicate_matrix[i, :], direction), 0):
                lambdas.append(np.nan)
            else:
                temp = auxiliary_points[i] - current_point
                lam = np.matmul(self.predicate_matrix[i, :], temp) / (np.matmul(self.predicate_matrix[i, :],
                                                                                direction))
                lambdas.append(lam)
        lambdas = np.array(lambdas)

        try:
            lam_upper = np.min(lambdas[lambdas &gt;= 0])
            lam_lower = np.max(lambdas[lambdas &lt; 0])
        except Exception:
            raise RuntimeError(&#34;The current direction does not intersect&#34;
                               &#34;any of the hyperplanes.&#34;)

        increment = np.random.uniform(low=lam_lower, high=lam_upper)
        next_point = current_point + increment * direction
        if self.check_alpha_inside(next_point):
            current_point = next_point
            star_point = self.center + np.matmul(self.basis_matrix, current_point)
            samples.append(star_point)
            self.__current_point = current_point

    return samples</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pynever.strategies.abstraction.StarSet"><code class="flex name class">
<span>class <span class="ident">StarSet</span></span>
<span>(</span><span>stars:Set[<a title="pynever.strategies.abstraction.Star" href="#pynever.strategies.abstraction.Star">Star</a>]=None, identifier:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Concrete class for our internal representation of a StarSet abstract element. A StarSet consist in a set
of Star objects.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>stars</code></strong> :&ensp;<code>Set[<a title="pynever.strategies.abstraction.Star" href="#pynever.strategies.abstraction.Star">Star</a>]</code></dt>
<dd>Set of Star objects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StarSet(AbsElement):
    &#34;&#34;&#34;
    Concrete class for our internal representation of a StarSet abstract element. A StarSet consist in a set
    of Star objects.

    Attributes
    ----------
    stars : Set[Star]
        Set of Star objects.
    &#34;&#34;&#34;

    def __init__(self, stars: Set[Star] = None, identifier: str = None):
        super().__init__(identifier)
        if stars is None:
            self.stars = set()
        else:
            self.stars = stars</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pynever.strategies.abstraction.AbsElement" href="#pynever.strategies.abstraction.AbsElement">AbsElement</a></li>
<li>abc.ABC</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pynever.strategies" href="index.html">pynever.strategies</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pynever.strategies.abstraction.area_sig_triangle" href="#pynever.strategies.abstraction.area_sig_triangle">area_sig_triangle</a></code></li>
<li><code><a title="pynever.strategies.abstraction.intersect_with_halfspace" href="#pynever.strategies.abstraction.intersect_with_halfspace">intersect_with_halfspace</a></code></li>
<li><code><a title="pynever.strategies.abstraction.mixed_single_relu_forward" href="#pynever.strategies.abstraction.mixed_single_relu_forward">mixed_single_relu_forward</a></code></li>
<li><code><a title="pynever.strategies.abstraction.sig" href="#pynever.strategies.abstraction.sig">sig</a></code></li>
<li><code><a title="pynever.strategies.abstraction.sig_fod" href="#pynever.strategies.abstraction.sig_fod">sig_fod</a></code></li>
<li><code><a title="pynever.strategies.abstraction.single_fc_forward" href="#pynever.strategies.abstraction.single_fc_forward">single_fc_forward</a></code></li>
<li><code><a title="pynever.strategies.abstraction.single_sigmoid_forward" href="#pynever.strategies.abstraction.single_sigmoid_forward">single_sigmoid_forward</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pynever.strategies.abstraction.AbsElement" href="#pynever.strategies.abstraction.AbsElement">AbsElement</a></code></h4>
</li>
<li>
<h4><code><a title="pynever.strategies.abstraction.AbsFullyConnectedNode" href="#pynever.strategies.abstraction.AbsFullyConnectedNode">AbsFullyConnectedNode</a></code></h4>
</li>
<li>
<h4><code><a title="pynever.strategies.abstraction.AbsLayerNode" href="#pynever.strategies.abstraction.AbsLayerNode">AbsLayerNode</a></code></h4>
<ul class="">
<li><code><a title="pynever.strategies.abstraction.AbsLayerNode.backward" href="#pynever.strategies.abstraction.AbsLayerNode.backward">backward</a></code></li>
<li><code><a title="pynever.strategies.abstraction.AbsLayerNode.forward" href="#pynever.strategies.abstraction.AbsLayerNode.forward">forward</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pynever.strategies.abstraction.AbsNeuralNetwork" href="#pynever.strategies.abstraction.AbsNeuralNetwork">AbsNeuralNetwork</a></code></h4>
<ul class="">
<li><code><a title="pynever.strategies.abstraction.AbsNeuralNetwork.backward" href="#pynever.strategies.abstraction.AbsNeuralNetwork.backward">backward</a></code></li>
<li><code><a title="pynever.strategies.abstraction.AbsNeuralNetwork.forward" href="#pynever.strategies.abstraction.AbsNeuralNetwork.forward">forward</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pynever.strategies.abstraction.AbsReLUNode" href="#pynever.strategies.abstraction.AbsReLUNode">AbsReLUNode</a></code></h4>
</li>
<li>
<h4><code><a title="pynever.strategies.abstraction.AbsSeqNetwork" href="#pynever.strategies.abstraction.AbsSeqNetwork">AbsSeqNetwork</a></code></h4>
<ul class="">
<li><code><a title="pynever.strategies.abstraction.AbsSeqNetwork.add_node" href="#pynever.strategies.abstraction.AbsSeqNetwork.add_node">add_node</a></code></li>
<li><code><a title="pynever.strategies.abstraction.AbsSeqNetwork.get_first_node" href="#pynever.strategies.abstraction.AbsSeqNetwork.get_first_node">get_first_node</a></code></li>
<li><code><a title="pynever.strategies.abstraction.AbsSeqNetwork.get_last_node" href="#pynever.strategies.abstraction.AbsSeqNetwork.get_last_node">get_last_node</a></code></li>
<li><code><a title="pynever.strategies.abstraction.AbsSeqNetwork.get_next_node" href="#pynever.strategies.abstraction.AbsSeqNetwork.get_next_node">get_next_node</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pynever.strategies.abstraction.AbsSigmoidNode" href="#pynever.strategies.abstraction.AbsSigmoidNode">AbsSigmoidNode</a></code></h4>
</li>
<li>
<h4><code><a title="pynever.strategies.abstraction.RefinementState" href="#pynever.strategies.abstraction.RefinementState">RefinementState</a></code></h4>
</li>
<li>
<h4><code><a title="pynever.strategies.abstraction.Star" href="#pynever.strategies.abstraction.Star">Star</a></code></h4>
<ul class="">
<li><code><a title="pynever.strategies.abstraction.Star.check_alpha_inside" href="#pynever.strategies.abstraction.Star.check_alpha_inside">check_alpha_inside</a></code></li>
<li><code><a title="pynever.strategies.abstraction.Star.check_if_empty" href="#pynever.strategies.abstraction.Star.check_if_empty">check_if_empty</a></code></li>
<li><code><a title="pynever.strategies.abstraction.Star.check_point_inside" href="#pynever.strategies.abstraction.Star.check_point_inside">check_point_inside</a></code></li>
<li><code><a title="pynever.strategies.abstraction.Star.get_bounds" href="#pynever.strategies.abstraction.Star.get_bounds">get_bounds</a></code></li>
<li><code><a title="pynever.strategies.abstraction.Star.get_samples" href="#pynever.strategies.abstraction.Star.get_samples">get_samples</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pynever.strategies.abstraction.StarSet" href="#pynever.strategies.abstraction.StarSet">StarSet</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>